{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "nft-mint-flow",
  "type": "registry:block",
  "description": "Universal NFT minting component that auto-detects provider (Manifold, OpenSea, generic) and handles all complexity including ERC20 payments and approvals",
  "dependencies": [
    "lucide-react",
    "wagmi",
    "viem",
    "@farcaster/frame-wagmi-connector",
    "clsx",
    "tailwind-merge"
  ],
  "devDependencies": [],
  "registryDependencies": [
    "button",
    "sheet",
    "https://hellno-mini-app-ui.vercel.app/r/use-miniapp-sdk.json",
    "https://hellno-mini-app-ui.vercel.app/r/chains.json",
    "https://hellno-mini-app-ui.vercel.app/r/nft-standards.json",
    "https://hellno-mini-app-ui.vercel.app/r/nft-card.json"
  ],
  "files": [
    {
      "path": "registry/mini-app/blocks/nft-mint-flow/nft-mint-flow.tsx",
      "content": "\"use client\";\n\nimport * as React from \"react\";\nimport { NFTCard } from \"@/registry/mini-app/blocks/nft-card/nft-card\";\nimport { NFTMintButton } from \"./nft-mint-button\";\n\ninterface NFTMintPageProps {\n  contractAddress: `0x${string}`;\n  tokenId: string;\n  network?: string;\n  chainId: 1 | 8453;\n  provider?: \"manifold\" | \"opensea\" | \"zora\" | \"generic\";\n  manifoldParams?: {\n    instanceId?: string;\n    tokenId?: string;\n  };\n  buttonText?: string;\n  cardSize?: number;\n}\n\n/**\n * NFT Mint Page - Complete NFT display and minting experience\n * \n * This component combines NFTCard for preview and NFTMintFlow for minting\n * in a properly aligned vertical layout.\n * \n * @example\n * ```tsx\n * <NFTMintPage\n *   contractAddress=\"0x32dd0a7190b5bba94549a0d04659a9258f5b1387\"\n *   tokenId=\"2\"\n *   network=\"base\"\n *   chainId={8453}\n *   provider=\"manifold\"\n *   manifoldParams={{\n *     instanceId: \"4293509360\",\n *     tokenId: \"2\"\n *   }}\n * />\n * ```\n */\nexport function NFTMintFlow({\n  contractAddress,\n  tokenId,\n  network = \"ethereum\",\n  chainId,\n  provider,\n  manifoldParams,\n  buttonText = \"Mint NFT\",\n  cardSize = 350,\n}: NFTMintPageProps) {\n  return (\n    <div \n      className=\"space-y-4 mx-auto\"\n      style={{ width: `${cardSize}px` }}\n    >\n      <NFTCard \n        contractAddress={contractAddress}\n        tokenId={tokenId}\n        network={network}\n        width={cardSize}\n        height={cardSize}\n        rounded=\"xl\"\n        shadow={true}\n        showTitle={true}\n        showNetwork={true}\n        titlePosition=\"outside\"\n        networkPosition=\"outside\"\n      />\n      \n      <NFTMintButton\n        contractAddress={contractAddress}\n        chainId={chainId}\n        provider={provider}\n        manifoldParams={manifoldParams}\n        buttonText={buttonText}\n        variant=\"default\"\n        size=\"lg\"\n        className=\"w-full\"\n      />\n    </div>\n  );\n}",
      "type": "registry:component"
    },
    {
      "path": "registry/mini-app/blocks/nft-mint-flow/nft-mint-button.tsx",
      "content": "\"use client\";\n\nimport * as React from \"react\";\nimport { Button } from \"@/registry/mini-app/ui/button\";\nimport {\n  Sheet,\n  SheetContent,\n  SheetHeader,\n  SheetTitle,\n} from \"@/registry/mini-app/ui/sheet\";\nimport { useMiniAppSdk } from \"@/registry/mini-app/hooks/use-miniapp-sdk\";\nimport {\n  useAccount,\n  useConnect,\n  useWaitForTransactionReceipt,\n  useWriteContract,\n  useSwitchChain,\n} from \"wagmi\";\nimport { formatEther, type Address } from \"viem\";\nimport { farcasterFrame } from \"@farcaster/frame-wagmi-connector\";\nimport {\n  Coins,\n  CheckCircle,\n  AlertCircle,\n  Loader2,\n  Info,\n  ExternalLink,\n  RefreshCw,\n  Wallet,\n} from \"lucide-react\";\nimport { cn } from \"@/lib/utils\";\nimport {\n  detectNFTProvider,\n  validateParameters,\n  getClientForChain,\n} from \"./lib/provider-detector\";\nimport { getProviderConfig } from \"./lib/provider-configs\";\nimport { fetchPriceData } from \"./lib/price-optimizer\";\nimport { mintReducer, initialState, type MintStep } from \"./lib/mint-reducer\";\nimport type { MintParams } from \"./lib/types\";\nimport { parseError, type ParsedError } from \"./lib/error-parser\";\n\n/**\n * NFTMintButton - Universal NFT minting button with automatic provider detection and ERC20 approval handling\n *\n * @example\n * ```tsx\n * // Basic ETH mint (auto-detects provider)\n * <NFTMintButton\n *   contractAddress=\"0x5b97886E4e1fC0F7d19146DEC03C917994b3c3a4\"\n *   chainId={1}\n * />\n *\n * // Manifold NFT with ERC20 payment (HIGHER token)\n * <NFTMintButton\n *   contractAddress=\"0x32dd0a7190b5bba94549a0d04659a9258f5b1387\"\n *   chainId={8453}\n *   provider=\"manifold\"\n *   manifoldParams={{ instanceId: \"4293509360\", tokenId: \"2\" }}\n * />\n *\n * // Multiple NFTs with custom button\n * <NFTMintButton\n *   contractAddress=\"0x...\"\n *   chainId={8453}\n *   amount={5}\n *   buttonText=\"Mint 5 NFTs\"\n *   onMintSuccess={(txHash) => console.log('Minted!', txHash)}\n * />\n * ```\n */\ntype NFTMintFlowProps = {\n  /**\n   * NFT contract address (0x...). This should be the main NFT contract, not the minting contract.\n   * For Manifold, this is the creator contract, not the extension.\n   */\n  contractAddress: Address;\n\n  /**\n   * Blockchain network ID\n   * - 1 = Ethereum mainnet\n   * - 8453 = Base mainnet\n   */\n  chainId: 1 | 8453;\n\n  /**\n   * Optional provider hint. Use when:\n   * - Auto-detection is failing\n   * - You know the provider and want faster loading\n   * - Testing specific provider flows\n   *\n   * Leave undefined for automatic detection.\n   */\n  provider?: \"manifold\" | \"opensea\" | \"zora\" | \"generic\";\n\n  /**\n   * Number of NFTs to mint. Defaults to 1.\n   * Note: For ERC20 payments, the total cost is multiplied by this amount.\n   */\n  amount?: number;\n\n  /**\n   * Manifold-specific parameters. Required when provider=\"manifold\".\n   * - instanceId: The claim instance ID from Manifold (required for most Manifold NFTs)\n   * - tokenId: The specific token ID (required for some editions)\n   *\n   * Find these in the Manifold claim page URL or contract details.\n   */\n  manifoldParams?: {\n    instanceId?: string;\n    tokenId?: string;\n  };\n\n  // UI customization\n  /** Additional CSS classes */\n  className?: string;\n  /** Button style variant */\n  variant?: \"default\" | \"destructive\" | \"secondary\" | \"ghost\" | \"outline\";\n  /** Button size */\n  size?: \"default\" | \"sm\" | \"lg\" | \"icon\";\n  /** Custom button text. Defaults to \"Mint NFT\" */\n  buttonText?: string;\n  /** Disable the mint button */\n  disabled?: boolean;\n\n  /**\n   * Called when NFT minting succeeds (not on approval success)\n   * @param txHash - The mint transaction hash (not approval tx)\n   */\n  onMintSuccess?: (txHash: string) => void;\n\n  /**\n   * Called when NFT minting fails (not on approval failure)\n   * @param error - Human-readable error message\n   */\n  onMintError?: (error: string) => void;\n};\n\nexport function NFTMintButton({\n  contractAddress,\n  chainId,\n  provider,\n  amount = 1,\n  manifoldParams,\n  className,\n  variant = \"default\",\n  size = \"default\",\n  buttonText = \"Mint NFT\",\n  disabled = false,\n  onMintSuccess,\n  onMintError,\n}: NFTMintFlowProps) {\n  const [state, dispatch] = React.useReducer(mintReducer, initialState);\n  const [isSheetOpen, setIsSheetOpen] = React.useState(false);\n  const [parsedError, setParsedError] = React.useState<ParsedError | null>(null);\n\n  // Prop validation with helpful errors\n  React.useEffect(() => {\n    if (\n      provider === \"manifold\" &&\n      !manifoldParams?.instanceId &&\n      !manifoldParams?.tokenId\n    ) {\n      console.error(\n        \"NFTMintFlow: When provider='manifold', you must provide manifoldParams with either instanceId or tokenId. \" +\n          \"Example: manifoldParams={{ instanceId: '4293509360' }}\",\n      );\n    }\n\n    if (manifoldParams && provider !== \"manifold\") {\n      console.warn(\n        \"NFTMintFlow: manifoldParams provided but provider is not 'manifold'. \" +\n          \"Did you forget to set provider='manifold'?\",\n      );\n    }\n\n    if (chainId !== 1 && chainId !== 8453) {\n      console.warn(\n        `NFTMintFlow: Chain ID ${chainId} may not be supported. ` +\n          \"Currently tested chains: 1 (Ethereum), 8453 (Base)\",\n      );\n    }\n\n    if (!contractAddress || !contractAddress.match(/^0x[a-fA-F0-9]{40}$/)) {\n      console.error(\n        \"NFTMintFlow: Invalid contract address. Must be a valid Ethereum address (0x...)\",\n      );\n    }\n  }, [provider, manifoldParams, chainId, contractAddress]);\n\n  // Destructure commonly used values\n  const {\n    step,\n    contractInfo,\n    priceData,\n    error,\n    txHash,\n    txType,\n    isLoading,\n    validationErrors,\n  } = state;\n  const { erc20Details } = priceData;\n\n  const { isSDKLoaded } = useMiniAppSdk();\n  const { isConnected, address, chain } = useAccount();\n  const { connect } = useConnect();\n  const { switchChain } = useSwitchChain();\n  const {\n    writeContract,\n    isPending: isWritePending,\n    data: writeData,\n    error: writeError,\n  } = useWriteContract();\n\n  // Build mint params\n  const mintParams: MintParams = React.useMemo(\n    () => ({\n      contractAddress,\n      chainId,\n      provider,\n      amount,\n      instanceId: manifoldParams?.instanceId,\n      tokenId: manifoldParams?.tokenId,\n      recipient: address,\n    }),\n    [contractAddress, chainId, provider, amount, manifoldParams, address],\n  );\n\n  // Watch for transaction completion\n  const {\n    isSuccess: isTxSuccess,\n    isError: isTxError,\n    error: txError,\n  } = useWaitForTransactionReceipt({\n    hash: writeData,\n  });\n\n  // Get provider config\n  const providerConfig = contractInfo\n    ? getProviderConfig(contractInfo.provider)\n    : null;\n\n  // Check if user is on the correct network\n  const isCorrectNetwork = chain?.id === chainId;\n  const networkName = chainId === 1 ? \"Ethereum\" : chainId === 8453 ? \"Base\" : \"Unknown\";\n\n  // Handle transaction status updates\n  React.useEffect(() => {\n    if (writeError) {\n      const parsed = parseError(writeError, txType || \"mint\");\n      \n      // Don't show error state for user rejections - just close\n      if (parsed.type === \"user-rejected\") {\n        dispatch({ type: \"RESET\" });\n        setParsedError(null);\n        return;\n      }\n      \n      setParsedError(parsed);\n      dispatch({ type: \"TX_ERROR\", payload: writeError.message });\n      if (txType === \"mint\") {\n        onMintError?.(writeError.message);\n      }\n    }\n    if (isTxError && txError) {\n      const parsed = parseError(txError, txType || \"mint\");\n      setParsedError(parsed);\n      dispatch({ type: \"TX_ERROR\", payload: txError.message });\n      if (txType === \"mint\") {\n        onMintError?.(txError.message);\n      }\n    }\n    if (writeData && !isTxSuccess && !isTxError) {\n      // Transaction submitted, waiting for confirmation\n      if (txType === \"approval\") {\n        dispatch({ type: \"APPROVE_TX_SUBMITTED\", payload: writeData });\n      } else if (txType === \"mint\") {\n        dispatch({ type: \"MINT_TX_SUBMITTED\", payload: writeData });\n      }\n    }\n    if (isTxSuccess && writeData) {\n      if (txType === \"approval\") {\n        dispatch({ type: \"APPROVE_SUCCESS\" });\n      } else if (txType === \"mint\") {\n        dispatch({ type: \"TX_SUCCESS\", payload: writeData });\n        onMintSuccess?.(writeData);\n      }\n    }\n  }, [\n    isTxSuccess,\n    writeData,\n    onMintSuccess,\n    isTxError,\n    txError,\n    onMintError,\n    writeError,\n    txType,\n  ]);\n\n  // Auto-close on success after 10 seconds\n  React.useEffect(() => {\n    if (step === \"success\") {\n      const timer = setTimeout(() => {\n        handleClose();\n      }, 10000);\n      return () => clearTimeout(timer);\n    }\n  }, [step]);\n\n  const handleClose = React.useCallback(() => {\n    setIsSheetOpen(false);\n    dispatch({ type: \"RESET\" });\n    setParsedError(null);\n  }, []);\n\n  const handleSwitchNetwork = async () => {\n    try {\n      await switchChain({ chainId });\n    } catch (err) {\n      // Network switch failed - user likely rejected or wallet doesn't support it\n    }\n  };\n\n  // Detect NFT provider and validate\n  const detectAndValidate = async () => {\n    dispatch({ type: \"DETECT_START\" });\n\n    try {\n      // Detect provider\n      const info = await detectNFTProvider(mintParams);\n\n      // Validate parameters\n      const validation = validateParameters(mintParams, info);\n\n      if (!validation.isValid) {\n        dispatch({ type: \"VALIDATION_ERROR\", payload: validation.errors });\n        return;\n      }\n\n      // Fetch optimized price data\n      const client = getClientForChain(chainId);\n      const fetchedPriceData = await fetchPriceData(client, mintParams, info);\n\n      // Update contract info with ERC20 details and claim data\n      if (fetchedPriceData.erc20Details) {\n        info.erc20Token = fetchedPriceData.erc20Details\n          .address as `0x${string}`;\n        info.erc20Symbol = fetchedPriceData.erc20Details.symbol;\n        info.erc20Decimals = fetchedPriceData.erc20Details.decimals;\n      }\n\n      // Add claim data if available\n      if (fetchedPriceData.claim) {\n        info.claim = fetchedPriceData.claim;\n      }\n\n      dispatch({\n        type: \"DETECT_SUCCESS\",\n        payload: {\n          contractInfo: info,\n          priceData: {\n            mintPrice: fetchedPriceData.mintPrice,\n            totalCost: fetchedPriceData.totalCost,\n            erc20Details: fetchedPriceData.erc20Details,\n          },\n        },\n      });\n    } catch (err) {\n      dispatch({\n        type: \"DETECT_ERROR\",\n        payload: \"Failed to detect NFT contract type\",\n      });\n    }\n  };\n\n  // Check allowance only (without re-detecting everything)\n  const checkAllowanceOnly = React.useCallback(async () => {\n    if (!contractInfo || !erc20Details || !address) return;\n\n    try {\n      const client = getClientForChain(chainId);\n      const spenderAddress =\n        contractInfo.provider === \"manifold\" && contractInfo.extensionAddress\n          ? contractInfo.extensionAddress\n          : contractAddress;\n\n      const allowance = await client.readContract({\n        address: erc20Details.address as `0x${string}`,\n        abi: [\n          {\n            name: \"allowance\",\n            type: \"function\",\n            inputs: [\n              { name: \"owner\", type: \"address\" },\n              { name: \"spender\", type: \"address\" },\n            ],\n            outputs: [{ type: \"uint256\" }],\n            stateMutability: \"view\",\n          },\n        ],\n        functionName: \"allowance\",\n        args: [address, spenderAddress],\n      });\n\n      dispatch({ type: \"UPDATE_ALLOWANCE\", payload: allowance as bigint });\n    } catch (err) {\n      // Allowance check failed - will proceed without pre-checked allowance\n    }\n  }, [contractInfo, erc20Details, address, chainId, contractAddress]);\n\n  // Re-check allowance after wallet connection\n  React.useEffect(() => {\n    if (\n      isConnected &&\n      address &&\n      erc20Details &&\n      erc20Details.allowance === undefined\n    ) {\n      checkAllowanceOnly();\n    }\n  }, [isConnected, address, erc20Details, checkAllowanceOnly]);\n\n  const handleInitialMint = async () => {\n    if (!isSDKLoaded) {\n      dispatch({ type: \"TX_ERROR\", payload: \"Farcaster SDK not loaded\" });\n      setIsSheetOpen(true);\n      return;\n    }\n\n    setIsSheetOpen(true);\n    await detectAndValidate();\n  };\n\n  const handleConnectWallet = async () => {\n    try {\n      dispatch({ type: \"CONNECT_START\" });\n      const connector = farcasterFrame();\n      connect({ connector });\n    } catch (err) {\n      handleError(err, \"Failed to connect wallet\");\n    }\n  };\n\n  const handleApprove = async () => {\n    if (!isConnected || !erc20Details || !contractInfo?.claim) {\n      dispatch({\n        type: \"TX_ERROR\",\n        payload: \"Missing required information for approval\",\n      });\n      return;\n    }\n\n    try {\n      dispatch({ type: \"APPROVE_START\" });\n\n      // For Manifold, approve the extension contract, not the NFT contract\n      const spenderAddress =\n        contractInfo.provider === \"manifold\" && contractInfo.extensionAddress\n          ? contractInfo.extensionAddress\n          : contractAddress;\n\n      // Approve exact amount needed\n      await writeContract({\n        address: erc20Details.address as `0x${string}`,\n        abi: [\n          {\n            name: \"approve\",\n            type: \"function\",\n            inputs: [\n              { name: \"spender\", type: \"address\" },\n              { name: \"amount\", type: \"uint256\" },\n            ],\n            outputs: [{ type: \"bool\" }],\n            stateMutability: \"nonpayable\",\n          },\n        ],\n        functionName: \"approve\",\n        args: [spenderAddress, contractInfo.claim.cost],\n        chainId,\n      });\n      \n      // The transaction has been initiated - we'll track it via writeData in the effect\n    } catch (err) {\n      handleError(err, \"Approval failed\", \"approval\");\n    }\n  };\n\n  const handleMint = async () => {\n    if (!isConnected) {\n      await handleConnectWallet();\n      return;\n    }\n\n    if (!contractInfo || !providerConfig) {\n      dispatch({\n        type: \"TX_ERROR\",\n        payload: \"Contract information not available\",\n      });\n      return;\n    }\n\n    try {\n      dispatch({ type: \"MINT_START\" });\n\n      const args = providerConfig.mintConfig.buildArgs(mintParams);\n      const value = priceData.mintPrice\n        ? providerConfig.mintConfig.calculateValue(\n            priceData.mintPrice,\n            mintParams,\n          )\n        : BigInt(0);\n\n      // Handle Manifold's special case\n      const mintAddress =\n        contractInfo.provider === \"manifold\" && contractInfo.extensionAddress\n          ? contractInfo.extensionAddress\n          : contractAddress;\n\n      await writeContract({\n        address: mintAddress,\n        abi: providerConfig.mintConfig.abi,\n        functionName: providerConfig.mintConfig.functionName as any,\n        args,\n        value,\n        chainId,\n      });\n      \n      // The transaction has been initiated - we'll track it via writeData in the effect\n    } catch (err) {\n      handleError(err, \"Mint transaction failed\", \"mint\");\n    }\n  };\n\n  // Centralized error handler\n  const handleError = (\n    error: unknown,\n    context: string,\n    transactionType?: \"approval\" | \"mint\",\n  ) => {\n    console.error(`${context}:`, error);\n    const message = error instanceof Error ? error.message : `${context}`;\n    \n    // Parse the error for better UX\n    const parsed = parseError(error, transactionType || \"mint\");\n    setParsedError(parsed);\n    \n    dispatch({ type: \"TX_ERROR\", payload: message });\n    // Use explicit transaction type if provided, otherwise fall back to state\n    if ((transactionType || txType) === \"mint\") {\n      onMintError?.(message);\n    }\n  };\n\n  const handleRetry = () => {\n    dispatch({ type: \"RESET\" });\n    detectAndValidate();\n  };\n\n  // Display helpers (quick win: centralized formatting)\n  const formatPrice = (amount: bigint, decimals: number, symbol: string) => {\n    if (amount === BigInt(0)) return \"Free\";\n    return `${Number(amount) / 10 ** decimals} ${symbol}`;\n  };\n\n  const displayPrice = () => {\n    if (erc20Details && contractInfo?.claim) {\n      return formatPrice(\n        contractInfo.claim.cost || BigInt(0),\n        erc20Details.decimals || 18,\n        erc20Details.symbol,\n      );\n    }\n    return priceData.mintPrice\n      ? `${formatEther(priceData.mintPrice)} ETH`\n      : \"Free\";\n  };\n\n  const displayTotalCost = () => {\n    if (erc20Details && contractInfo?.claim) {\n      // For Manifold, cost is per claim, not per NFT amount\n      return formatPrice(\n        contractInfo.claim.cost || BigInt(0),\n        erc20Details.decimals || 18,\n        erc20Details.symbol,\n      );\n    }\n    return priceData.totalCost\n      ? `${formatEther(priceData.totalCost)} ETH`\n      : \"Free\";\n  };\n\n  const displayMintFee = () => {\n    const fee = priceData.mintPrice || BigInt(0);\n    return fee > BigInt(0) ? `${formatEther(fee)} ETH` : \"0 ETH\";\n  };\n\n  const providerName = contractInfo?.provider\n    ? contractInfo.provider.charAt(0).toUpperCase() +\n      contractInfo.provider.slice(1)\n    : \"Unknown\";\n\n  // Quick win: validation helper\n  const isReadyToMint = () => {\n    return (\n      isConnected &&\n      contractInfo &&\n      !isLoading &&\n      step === \"sheet\" &&\n      (!erc20Details || !erc20Details.needsApproval)\n    );\n  };\n\n  return (\n    <Sheet\n      open={isSheetOpen}\n      onOpenChange={(open) => {\n        setIsSheetOpen(open);\n        if (!open) {\n          handleClose();\n        }\n      }}\n    >\n      <Button\n        variant={variant}\n        size={size}\n        onClick={handleInitialMint}\n        disabled={disabled || !isSDKLoaded || isLoading}\n        className={cn(\"w-full\", className)}\n      >\n        <Coins className=\"h-4 w-4 mr-2\" />\n        {buttonText}\n      </Button>\n\n      <SheetContent\n        side=\"bottom\"\n        onClose={handleClose}\n        className=\"!bottom-0 !rounded-t-xl !rounded-b-none !max-h-[90vh] !h-auto\"\n      >\n        <SheetHeader className=\"mb-6\">\n          <SheetTitle>\n            {step === \"detecting\" && \"Detecting NFT Type\"}\n            {step === \"sheet\" && \"Mint NFT\"}\n            {step === \"connecting\" && \"Connecting Wallet\"}\n            {step === \"approve\" && \"Approve Token\"}\n            {step === \"approving\" && \"Approving...\"}\n            {step === \"minting\" && \"Preparing Mint\"}\n            {step === \"waiting\" &&\n              (txType === \"approval\" ? \"Approving...\" : \"Minting...\")}\n            {step === \"success\" && \"Mint Successful!\"}\n            {step === \"error\" && \"Transaction Failed\"}\n            {step === \"validation-error\" && \"Missing Information\"}\n          </SheetTitle>\n        </SheetHeader>\n\n        {/* Detecting Provider */}\n        {step === \"detecting\" && (\n          <div className=\"text-center space-y-4\">\n            <div className=\"flex justify-center\">\n              <Loader2 className=\"h-12 w-12 animate-spin text-primary\" />\n            </div>\n            <p className=\"text-muted-foreground\">\n              Detecting NFT contract type...\n            </p>\n          </div>\n        )}\n\n        {/* Validation Error */}\n        {step === \"validation-error\" && (\n          <div className=\"space-y-4\">\n            <div className=\"flex justify-center\">\n              <Info className=\"h-12 w-12 text-yellow-500\" />\n            </div>\n            <div className=\"space-y-2\">\n              <p className=\"font-semibold text-center\">\n                Missing Required Information\n              </p>\n              {validationErrors.map((err, idx) => (\n                <p\n                  key={idx}\n                  className=\"text-sm text-muted-foreground text-center\"\n                >\n                  {err}\n                </p>\n              ))}\n            </div>\n            <Button onClick={handleClose} className=\"w-full\">\n              Close\n            </Button>\n          </div>\n        )}\n\n        {/* Approve Step */}\n        {step === \"approve\" && erc20Details && (\n          <div className=\"space-y-6\">\n            <div className=\"text-center space-y-2\">\n              <p className=\"font-semibold\">Approval Required</p>\n              <p className=\"text-sm text-muted-foreground\">\n                This NFT requires payment in {erc20Details.symbol}. You need to\n                approve the contract to spend your tokens.\n              </p>\n            </div>\n            <div className=\"space-y-4\">\n              <div className=\"flex justify-between items-center py-3 border-b\">\n                <span className=\"text-muted-foreground\">Token</span>\n                <span className=\"font-semibold\">{erc20Details.symbol}</span>\n              </div>\n              <div className=\"flex justify-between items-center py-3 border-b\">\n                <span className=\"text-muted-foreground\">Amount to Approve</span>\n                <span className=\"font-semibold\">\n                  {contractInfo?.claim\n                    ? Number(contractInfo.claim.cost) /\n                      10 ** erc20Details.decimals\n                    : 0}{\" \"}\n                  {erc20Details.symbol}\n                </span>\n              </div>\n            </div>\n            <Button\n              onClick={handleApprove}\n              size=\"lg\"\n              className=\"w-full\"\n              disabled={isWritePending}\n            >\n              <Coins className=\"h-5 w-5 mr-2\" />\n              Approve {erc20Details.symbol}\n            </Button>\n          </div>\n        )}\n\n        {/* Main Sheet Content */}\n        {step === \"sheet\" && contractInfo && (\n          <div className=\"space-y-6\">\n            {/* Network warning */}\n            {!isCorrectNetwork && isConnected && (\n              <div className=\"bg-yellow-50 border border-yellow-200 rounded-lg p-3\">\n                <div className=\"flex items-center justify-between\">\n                  <div className=\"flex items-center gap-2\">\n                    <Info className=\"h-4 w-4 text-yellow-600\" />\n                    <p className=\"text-sm font-medium\">Wrong network</p>\n                  </div>\n                  <Button\n                    onClick={handleSwitchNetwork}\n                    size=\"sm\"\n                    variant=\"ghost\"\n                    className=\"text-xs\"\n                  >\n                    Switch to {networkName}\n                  </Button>\n                </div>\n              </div>\n            )}\n            \n            <div className=\"space-y-4\">\n              <div className=\"flex justify-between items-center py-3 border-b\">\n                <span className=\"text-muted-foreground\">Provider</span>\n                <span className=\"font-semibold\">{providerName}</span>\n              </div>\n              <div className=\"flex justify-between items-center py-3 border-b\">\n                <span className=\"text-muted-foreground\">Contract</span>\n                <span className=\"font-mono text-sm\">\n                  {contractAddress.slice(0, 6)}...{contractAddress.slice(-4)}\n                </span>\n              </div>\n              <div className=\"flex justify-between items-center py-3 border-b\">\n                <span className=\"text-muted-foreground\">Quantity</span>\n                <span className=\"font-semibold\">{amount}</span>\n              </div>\n              <div className=\"flex justify-between items-center py-3 border-b\">\n                <span className=\"text-muted-foreground\">Price per NFT</span>\n                <span className=\"font-semibold\">{displayPrice()}</span>\n              </div>\n              {erc20Details && (\n                <div className=\"flex justify-between items-center py-3 border-b\">\n                  <span className=\"text-muted-foreground\">Mint Fee</span>\n                  <span className=\"font-semibold\">{displayMintFee()}</span>\n                </div>\n              )}\n              <div className=\"flex justify-between items-center py-3 text-lg font-semibold\">\n                <span>Total Cost</span>\n                <span>{displayTotalCost()}</span>\n              </div>\n            </div>\n\n            <Button\n              onClick={isConnected ? handleMint : handleConnectWallet}\n              size=\"lg\"\n              className=\"w-full\"\n              disabled={isWritePending || !isReadyToMint() || (!isCorrectNetwork && isConnected)}\n            >\n              {isConnected ? (\n                !isCorrectNetwork ? (\n                  \"Switch Network to Mint\"\n                ) : (\n                  <>\n                    <Coins className=\"h-5 w-5 mr-2\" />\n                    Mint {amount} NFT{amount > 1 ? \"s\" : \"\"}\n                  </>\n                )\n              ) : (\n                \"Connect Wallet to Mint\"\n              )}\n            </Button>\n          </div>\n        )}\n\n        {/* Connecting */}\n        {step === \"connecting\" && (\n          <div className=\"text-center space-y-4\">\n            <div className=\"flex justify-center\">\n              <Loader2 className=\"h-12 w-12 animate-spin text-primary\" />\n            </div>\n            <p className=\"text-muted-foreground\">\n              Connecting to your Farcaster wallet...\n            </p>\n          </div>\n        )}\n\n        {/* Minting/Approving */}\n        {(step === \"minting\" || step === \"approving\") && (\n          <div className=\"text-center space-y-4\">\n            <div className=\"flex justify-center\">\n              <Loader2 className=\"h-12 w-12 animate-spin text-primary\" />\n            </div>\n            <div>\n              <p className=\"font-semibold\">\n                {step === \"approving\"\n                  ? \"Preparing approval\"\n                  : \"Preparing mint transaction\"}\n              </p>\n              <p className=\"text-sm text-muted-foreground\">\n                Please approve the transaction in your wallet\n              </p>\n            </div>\n          </div>\n        )}\n\n        {/* Waiting for Transaction */}\n        {step === \"waiting\" && (\n          <div className=\"text-center space-y-4\">\n            <div className=\"flex justify-center\">\n              <Loader2 className=\"h-12 w-12 animate-spin text-primary\" />\n            </div>\n            <div>\n              <p className=\"font-semibold\">\n                {txType === \"approval\"\n                  ? \"Approval submitted\"\n                  : \"Transaction submitted\"}\n              </p>\n              <p className=\"text-sm text-muted-foreground\">\n                Waiting for confirmation on the blockchain...\n              </p>\n              {txHash && (\n                <p className=\"text-xs font-mono mt-2 px-3 py-1 bg-muted rounded\">\n                  {txHash.slice(0, 10)}...{txHash.slice(-8)}\n                </p>\n              )}\n            </div>\n          </div>\n        )}\n\n        {/* Success */}\n        {step === \"success\" && (\n          <div className=\"text-center space-y-6\">\n            <div className=\"flex justify-center\">\n              <CheckCircle className=\"h-20 w-20 text-green-500\" />\n            </div>\n            <div className=\"space-y-3\">\n              <p className=\"text-2xl font-semibold\">Minted! ðŸŽ‰</p>\n              <p className=\"text-muted-foreground\">\n                {amount} NFT{amount > 1 ? \"s\" : \"\"} successfully minted\n              </p>\n            </div>\n            {txHash && (\n              <div className=\"space-y-3\">\n                <Button variant=\"outline\" size=\"sm\" className=\"gap-2\" asChild>\n                  <a\n                    href={`https://txha.sh/${txHash}`}\n                    target=\"_blank\"\n                    rel=\"noopener noreferrer\"\n                  >\n                    View transaction\n                    <ExternalLink className=\"h-3 w-3\" />\n                  </a>\n                </Button>\n              </div>\n            )}\n            <Button onClick={handleClose} className=\"w-full\" size=\"lg\">\n              Done\n            </Button>\n          </div>\n        )}\n\n        {/* Error State */}\n        {step === \"error\" && (\n          <div className=\"space-y-6\">\n            <div className=\"text-center space-y-4\">\n              <div className=\"flex justify-center\">\n                <div className=\"p-3 bg-red-50 rounded-full\">\n                  <AlertCircle className=\"h-12 w-12 text-red-500\" />\n                </div>\n              </div>\n              <div className=\"space-y-2\">\n                <p className=\"font-semibold text-lg\">\n                  {parsedError?.message || \"Transaction Failed\"}\n                </p>\n                {parsedError?.details && (\n                  <p className=\"text-sm text-muted-foreground max-w-sm mx-auto\">\n                    {parsedError.details}\n                  </p>\n                )}\n              </div>\n            </div>\n\n            {/* Special handling for wrong network */}\n            {!isCorrectNetwork && isConnected && (\n              <div className=\"bg-yellow-50 border border-yellow-200 rounded-lg p-4 space-y-3\">\n                <div className=\"flex items-center gap-2\">\n                  <Info className=\"h-5 w-5 text-yellow-600 flex-shrink-0\" />\n                  <div>\n                    <p className=\"font-medium text-sm\">Wrong Network</p>\n                    <p className=\"text-sm text-muted-foreground\">\n                      Please switch to {networkName} to continue\n                    </p>\n                  </div>\n                </div>\n                <Button\n                  onClick={handleSwitchNetwork}\n                  size=\"sm\"\n                  className=\"w-full\"\n                  variant=\"outline\"\n                >\n                  Switch to {networkName}\n                </Button>\n              </div>\n            )}\n\n            {/* Specific error actions */}\n            {parsedError?.type === \"insufficient-funds\" && (\n              <div className=\"bg-blue-50 border border-blue-200 rounded-lg p-4\">\n                <div className=\"flex items-start gap-2\">\n                  <Wallet className=\"h-5 w-5 text-blue-600 flex-shrink-0 mt-0.5\" />\n                  <div className=\"text-sm\">\n                    <p className=\"font-medium mb-1\">Insufficient Balance</p>\n                    <p className=\"text-muted-foreground\">\n                      Make sure you have enough:\n                    </p>\n                    <ul className=\"list-disc list-inside text-muted-foreground mt-1\">\n                      {erc20Details ? (\n                        <>\n                          <li>{erc20Details.symbol} for the NFT price</li>\n                          <li>ETH for gas fees</li>\n                        </>\n                      ) : (\n                        <li>ETH for both NFT price and gas fees</li>\n                      )}\n                    </ul>\n                  </div>\n                </div>\n              </div>\n            )}\n\n            {/* Action buttons */}\n            <div className=\"flex gap-3\">\n              <Button\n                variant=\"outline\"\n                onClick={handleClose}\n                className=\"flex-1\"\n              >\n                Close\n              </Button>\n              <Button \n                onClick={handleRetry} \n                className=\"flex-1\"\n                disabled={!isCorrectNetwork && isConnected}\n              >\n                <RefreshCw className=\"h-4 w-4 mr-2\" />\n                {parsedError?.actionText || \"Try Again\"}\n              </Button>\n            </div>\n          </div>\n        )}\n      </SheetContent>\n    </Sheet>\n  );\n}\n\n/**\n * Preset builders for common NFT minting scenarios.\n * These provide type-safe, self-documenting ways to create NFTMintButton components.\n */\nNFTMintButton.presets = {\n  /**\n   * Create a basic ETH-based NFT mint\n   * @example\n   * ```tsx\n   * <NFTMintButton {...NFTMintButton.presets.generic({\n   *   contractAddress: \"0x5b97886E4e1fC0F7d19146DEC03C917994b3c3a4\",\n   *   chainId: 1,\n   *   amount: 1\n   * })} />\n   * ```\n   */\n  generic: (props: {\n    contractAddress: Address;\n    chainId: 1 | 8453;\n    amount?: number;\n    buttonText?: string;\n    onMintSuccess?: (txHash: string) => void;\n    onMintError?: (error: string) => void;\n  }): NFTMintFlowProps => ({\n    ...props,\n    provider: \"generic\",\n    amount: props.amount || 1,\n  }),\n\n  /**\n   * Create a Manifold NFT mint with proper configuration\n   * @example\n   * ```tsx\n   * <NFTMintButton {...NFTMintButton.presets.manifold({\n   *   contractAddress: \"0x32dd0a7190b5bba94549a0d04659a9258f5b1387\",\n   *   chainId: 8453,\n   *   instanceId: \"4293509360\"\n   * })} />\n   * ```\n   */\n  manifold: (props: {\n    contractAddress: Address;\n    chainId: 1 | 8453;\n    instanceId: string;\n    tokenId?: string;\n    amount?: number;\n    buttonText?: string;\n    onMintSuccess?: (txHash: string) => void;\n    onMintError?: (error: string) => void;\n  }): NFTMintFlowProps => ({\n    contractAddress: props.contractAddress,\n    chainId: props.chainId,\n    provider: \"manifold\",\n    manifoldParams: {\n      instanceId: props.instanceId,\n      tokenId: props.tokenId,\n    },\n    amount: props.amount || 1,\n    buttonText: props.buttonText,\n    onMintSuccess: props.onMintSuccess,\n    onMintError: props.onMintError,\n  }),\n\n  /**\n   * Create an auto-detecting NFT mint (tries to figure out the provider)\n   * @example\n   * ```tsx\n   * <NFTMintButton {...NFTMintButton.presets.auto({\n   *   contractAddress: \"0x...\",\n   *   chainId: 8453\n   * })} />\n   * ```\n   */\n  auto: (props: {\n    contractAddress: Address;\n    chainId: 1 | 8453;\n    amount?: number;\n    buttonText?: string;\n    onMintSuccess?: (txHash: string) => void;\n    onMintError?: (error: string) => void;\n  }): NFTMintFlowProps => ({\n    ...props,\n    amount: props.amount || 1,\n  }),\n};\n",
      "type": "registry:component"
    },
    {
      "path": "registry/mini-app/blocks/nft-mint-flow/lib/types.ts",
      "content": "import type { Address } from \"viem\";\n\nexport type NFTProvider = \"manifold\" | \"opensea\" | \"zora\" | \"generic\";\n\nexport interface ProviderConfig {\n  name: NFTProvider;\n  detectPattern?: RegExp;\n  extensionAddresses?: Address[];\n  priceDiscovery: PriceDiscoveryConfig;\n  mintConfig: MintConfig;\n  requiredParams: string[];\n  supportsERC20: boolean;\n}\n\nexport interface PriceDiscoveryConfig {\n  abis: any[];\n  functionNames: string[];\n  requiresInstanceId?: boolean;\n}\n\nexport interface MintConfig {\n  abi: any;\n  functionName: string;\n  buildArgs: (params: MintParams) => any[];\n  calculateValue: (price: bigint, params: MintParams) => bigint;\n}\n\nexport interface MintParams {\n  contractAddress: Address;\n  chainId: number;\n  provider?: NFTProvider;\n  amount?: number;\n  instanceId?: string;\n  tokenId?: string;\n  recipient?: Address;\n  merkleProof?: string[];\n}\n\nexport interface NFTContractInfo {\n  provider: NFTProvider;\n  isERC1155: boolean;\n  isERC721: boolean;\n  extensionAddress?: Address;\n  hasManifoldExtension?: boolean;\n  mintPrice?: bigint;\n  erc20Token?: Address;\n  erc20Symbol?: string;\n  erc20Decimals?: number;\n  claim?: {\n    cost: bigint;\n    merkleRoot: `0x${string}`;\n    erc20: Address;\n    startDate: number;\n    endDate: number;\n    walletMax: number;\n  };\n}\n\nexport interface ValidationResult {\n  isValid: boolean;\n  missingParams: string[];\n  errors: string[];\n  warnings: string[];\n}",
      "type": "registry:lib"
    },
    {
      "path": "registry/mini-app/blocks/nft-mint-flow/lib/provider-configs.ts",
      "content": "import { type Address } from \"viem\";\nimport type { ProviderConfig } from \"./types\";\nimport { MANIFOLD_EXTENSION_ABI, KNOWN_CONTRACTS, PRICE_DISCOVERY_ABI, MINT_ABI } from \"@/registry/mini-app/lib/nft-standards\";\n\nexport const PROVIDER_CONFIGS: Record<string, ProviderConfig> = {\n  manifold: {\n    name: \"manifold\",\n    extensionAddresses: [\n      KNOWN_CONTRACTS.manifoldExtension, // Known Manifold extension\n    ],\n    priceDiscovery: {\n      abis: [MANIFOLD_EXTENSION_ABI],\n      functionNames: [\"MINT_FEE\"],\n      requiresInstanceId: true\n    },\n    mintConfig: {\n      abi: MANIFOLD_EXTENSION_ABI,\n      functionName: \"mint\",\n      buildArgs: (params) => [\n        params.contractAddress,\n        BigInt(params.instanceId || \"0\"),\n        Number(params.tokenId || \"0\"),\n        params.merkleProof || [],\n        params.recipient\n      ],\n      calculateValue: (mintFee, params) => {\n        // For Manifold, value is just the mint fee\n        // The actual NFT cost might be in ERC20\n        return mintFee;\n      }\n    },\n    requiredParams: [\"contractAddress\", \"chainId\"],\n    supportsERC20: true\n  },\n  \n  opensea: {\n    name: \"opensea\",\n    priceDiscovery: {\n      abis: [PRICE_DISCOVERY_ABI],\n      functionNames: [\"mintPrice\", \"price\", \"publicMintPrice\"]\n    },\n    mintConfig: {\n      abi: MINT_ABI,\n      functionName: \"mint\",\n      buildArgs: (params) => [BigInt(params.amount || 1)],\n      calculateValue: (price, params) => price * BigInt(params.amount || 1)\n    },\n    requiredParams: [\"contractAddress\", \"chainId\"],\n    supportsERC20: false\n  },\n\n  zora: {\n    name: \"zora\",\n    priceDiscovery: {\n      abis: [PRICE_DISCOVERY_ABI],\n      functionNames: [\"mintPrice\", \"price\"]\n    },\n    mintConfig: {\n      abi: MINT_ABI,\n      functionName: \"mint\",\n      buildArgs: (params) => [params.recipient, BigInt(params.amount || 1)],\n      calculateValue: (price, params) => price * BigInt(params.amount || 1)\n    },\n    requiredParams: [\"contractAddress\", \"chainId\"],\n    supportsERC20: false\n  },\n\n  generic: {\n    name: \"generic\",\n    priceDiscovery: {\n      abis: [PRICE_DISCOVERY_ABI],\n      functionNames: [\"mintPrice\", \"price\", \"MINT_PRICE\", \"getMintPrice\"]\n    },\n    mintConfig: {\n      abi: MINT_ABI,\n      functionName: \"mint\",\n      buildArgs: (params) => [BigInt(params.amount || 1)],\n      calculateValue: (price, params) => price * BigInt(params.amount || 1)\n    },\n    requiredParams: [\"contractAddress\", \"chainId\"],\n    supportsERC20: false\n  }\n};\n\n// Helper to get config by provider name\nexport function getProviderConfig(provider: string): ProviderConfig {\n  return PROVIDER_CONFIGS[provider] || PROVIDER_CONFIGS.generic;\n}",
      "type": "registry:lib"
    },
    {
      "path": "registry/mini-app/blocks/nft-mint-flow/lib/provider-detector.ts",
      "content": "import { type Address, type PublicClient } from \"viem\";\nimport type { NFTProvider, NFTContractInfo, MintParams } from \"./types\";\nimport { PROVIDER_CONFIGS } from \"./provider-configs\";\nimport { getPublicClient } from \"@/registry/mini-app/lib/chains\";\nimport { \n  ERC165_ABI, \n  INTERFACE_IDS, \n  MANIFOLD_DETECTION_ABI \n} from \"@/registry/mini-app/lib/nft-standards\";\n\n// Re-export from shared library for backward compatibility\nexport const getClientForChain = getPublicClient;\n\n/**\n * Detects NFT provider and contract info with minimal RPC calls\n * Uses multicall where possible to batch requests\n */\nexport async function detectNFTProvider(params: MintParams): Promise<NFTContractInfo> {\n  const { contractAddress, chainId, provider: specifiedProvider } = params;\n  const client = getClientForChain(chainId);\n\n  // If provider is specified, use known configuration\n  if (specifiedProvider) {\n    const config = PROVIDER_CONFIGS[specifiedProvider];\n    \n    // For Manifold, we know the extension address\n    if (specifiedProvider === \"manifold\" && config.extensionAddresses?.[0]) {\n      return {\n        provider: \"manifold\",\n        isERC1155: true,  // Manifold contracts are typically ERC1155\n        isERC721: false,\n        extensionAddress: config.extensionAddresses[0],\n        hasManifoldExtension: true\n      };\n    }\n    \n    // For other providers, return basic info\n    return {\n      provider: specifiedProvider,\n      isERC1155: false,\n      isERC721: false\n    };\n  }\n\n  try {\n    // Batch 1: Check interfaces and Manifold extensions in parallel\n    const [isERC721, isERC1155, extensions] = await Promise.all([\n      client.readContract({\n        address: contractAddress,\n        abi: ERC165_ABI,\n        functionName: \"supportsInterface\",\n        args: [INTERFACE_IDS.ERC721]\n      }).catch(() => false),\n      \n      client.readContract({\n        address: contractAddress,\n        abi: ERC165_ABI,\n        functionName: \"supportsInterface\",\n        args: [INTERFACE_IDS.ERC1155]\n      }).catch(() => false),\n      \n      client.readContract({\n        address: contractAddress,\n        abi: MANIFOLD_DETECTION_ABI,\n        functionName: \"getExtensions\"\n      }).catch(() => null)\n    ]);\n\n    // Check if it's a Manifold contract\n    if (extensions && extensions.length > 0) {\n      const knownManifoldExtension = extensions.find(ext => \n        PROVIDER_CONFIGS.manifold.extensionAddresses?.includes(ext)\n      );\n      \n      if (knownManifoldExtension || extensions.length > 0) {\n        return {\n          provider: \"manifold\",\n          isERC1155: isERC1155 as boolean,\n          isERC721: isERC721 as boolean,\n          extensionAddress: knownManifoldExtension || extensions[0],\n          hasManifoldExtension: true\n        };\n      }\n    }\n\n    // TODO: Add detection for OpenSea, Zora, etc.\n    // For now, return generic\n    return {\n      provider: \"generic\",\n      isERC1155: isERC1155 as boolean,\n      isERC721: isERC721 as boolean\n    };\n\n  } catch (error) {\n    console.error(\"Error detecting NFT provider:\", error);\n    // Default to generic provider\n    return {\n      provider: \"generic\",\n      isERC1155: false,\n      isERC721: false\n    };\n  }\n}\n\n/**\n * Validates parameters based on detected provider\n */\nexport function validateParameters(params: MintParams, contractInfo: NFTContractInfo): {\n  isValid: boolean;\n  missingParams: string[];\n  errors: string[];\n} {\n  const config = PROVIDER_CONFIGS[contractInfo.provider];\n  const missingParams: string[] = [];\n  const errors: string[] = [];\n\n  // Check required params for the provider\n  for (const param of config.requiredParams) {\n    if (!params[param as keyof MintParams]) {\n      missingParams.push(param);\n    }\n  }\n\n  // Provider-specific validation\n  if (contractInfo.provider === \"manifold\") {\n    if (!params.instanceId && !params.tokenId) {\n      errors.push(\"Manifold NFTs require either instanceId or tokenId\");\n      missingParams.push(\"instanceId or tokenId\");\n    }\n    \n    if (contractInfo.claim?.merkleRoot && contractInfo.claim.merkleRoot !== \"0x0000000000000000000000000000000000000000000000000000000000000000\") {\n      errors.push(\"This NFT requires a merkle proof for minting - not supported yet\");\n    }\n  }\n\n  return {\n    isValid: missingParams.length === 0 && errors.length === 0,\n    missingParams,\n    errors\n  };\n}",
      "type": "registry:lib"
    },
    {
      "path": "registry/mini-app/blocks/nft-mint-flow/lib/price-optimizer.ts",
      "content": "import type { PublicClient } from \"viem\";\nimport type { NFTContractInfo, MintParams } from \"./types\";\nimport { getProviderConfig } from \"./provider-configs\";\n\n/**\n * Optimized price discovery that batches RPC calls where possible\n */\nexport async function fetchPriceData(\n  client: PublicClient,\n  params: MintParams,\n  contractInfo: NFTContractInfo\n): Promise<{\n  mintPrice?: bigint;\n  erc20Details?: {\n    address: string;\n    symbol: string;\n    decimals: number;\n    allowance?: bigint;\n    balance?: bigint;\n  };\n  totalCost: bigint;\n  claim?: NFTContractInfo[\"claim\"];\n}> {\n  const config = getProviderConfig(contractInfo.provider);\n  \n  if (contractInfo.provider === \"manifold\" && contractInfo.extensionAddress) {\n    // For Manifold, we need extension fee + claim cost\n    const calls = [\n      // Get MINT_FEE from extension\n      {\n        address: contractInfo.extensionAddress,\n        abi: config.mintConfig.abi,\n        functionName: \"MINT_FEE\",\n        args: []\n      }\n    ];\n    \n    // Add claim fetch if we have instanceId\n    if (params.instanceId) {\n      calls.push({\n        address: contractInfo.extensionAddress,\n        abi: config.mintConfig.abi,\n        functionName: \"getClaim\",\n        args: [params.contractAddress, BigInt(params.instanceId)]\n      } as any);\n    }\n    \n    try {\n      const results = await Promise.all(\n        calls.map(call => \n          client.readContract(call as any).catch(err => {\n            console.error(\"RPC call failed:\", err);\n            return null;\n          })\n        )\n      );\n      \n      const mintFee = results[0] as bigint | null;\n      const claim = results[1] as any;\n      \n      let totalCost = mintFee || BigInt(0);\n      let erc20Details = undefined;\n      \n      if (claim) {\n        // Store claim data in contractInfo for later use\n        contractInfo.claim = {\n          cost: claim.cost,\n          merkleRoot: claim.merkleRoot,\n          erc20: claim.erc20,\n          startDate: claim.startDate,\n          endDate: claim.endDate,\n          walletMax: claim.walletMax\n        };\n        \n        // Check if ERC20 payment\n        if (claim.erc20 && claim.erc20 !== \"0x0000000000000000000000000000000000000000\") {\n          // Batch ERC20 details fetch\n          const [symbol, decimals, allowance, balance] = await Promise.all([\n            client.readContract({\n              address: claim.erc20,\n              abi: [{ name: \"symbol\", type: \"function\", inputs: [], outputs: [{ type: \"string\" }], stateMutability: \"view\" }],\n              functionName: \"symbol\"\n            }),\n            client.readContract({\n              address: claim.erc20,\n              abi: [{ name: \"decimals\", type: \"function\", inputs: [], outputs: [{ type: \"uint8\" }], stateMutability: \"view\" }],\n              functionName: \"decimals\"\n            }),\n            params.recipient ? client.readContract({\n              address: claim.erc20,\n              abi: [{ \n                name: \"allowance\", \n                type: \"function\", \n                inputs: [{ name: \"owner\", type: \"address\" }, { name: \"spender\", type: \"address\" }], \n                outputs: [{ type: \"uint256\" }], \n                stateMutability: \"view\" \n              }],\n              functionName: \"allowance\",\n              args: [params.recipient, contractInfo.extensionAddress || params.contractAddress]\n            }).catch(() => BigInt(0)) : Promise.resolve(undefined), // Return undefined when no recipient, not 0\n            params.recipient ? client.readContract({\n              address: claim.erc20,\n              abi: [{ \n                name: \"balanceOf\", \n                type: \"function\", \n                inputs: [{ name: \"owner\", type: \"address\" }], \n                outputs: [{ type: \"uint256\" }], \n                stateMutability: \"view\" \n              }],\n              functionName: \"balanceOf\",\n              args: [params.recipient]\n            }).catch(() => BigInt(0)) : Promise.resolve(undefined)\n          ]);\n          \n          // Validate decimals\n          const validatedDecimals = Number(decimals);\n          if (isNaN(validatedDecimals) || validatedDecimals < 0 || validatedDecimals > 255) {\n            console.error(`Invalid ERC20 decimals for ${claim.erc20}:`, decimals);\n            throw new Error(`Invalid ERC20 decimals: ${decimals}`);\n          }\n          \n          erc20Details = {\n            address: claim.erc20,\n            symbol: symbol as string,\n            decimals: validatedDecimals,\n            allowance: allowance as bigint,\n            balance: balance as bigint | undefined\n          };\n          \n          // For ERC20, total cost in ETH is just the mint fee\n          totalCost = mintFee || BigInt(0);\n        } else {\n          // ETH payment - add claim cost to mint fee\n          totalCost = (mintFee || BigInt(0)) + (claim.cost || BigInt(0));\n        }\n      }\n      \n      return {\n        mintPrice: mintFee || BigInt(0),\n        erc20Details,\n        totalCost,\n        claim: claim ? contractInfo.claim : undefined\n      };\n    } catch (err) {\n      console.error(\"Failed to fetch Manifold price data:\", err);\n      return { totalCost: BigInt(0) };\n    }\n  } else {\n    // Generic price discovery - try multiple function names\n    const functionNames = config.priceDiscovery.functionNames;\n    \n    for (const functionName of functionNames) {\n      try {\n        const price = await client.readContract({\n          address: params.contractAddress,\n          abi: config.priceDiscovery.abis[0],\n          functionName: functionName as any,\n          args: []\n        });\n        \n        if (price !== undefined) {\n          const totalCost = (price as bigint) * BigInt(params.amount || 1);\n          return {\n            mintPrice: price as bigint,\n            totalCost\n          };\n        }\n      } catch {\n        // Try next function name\n        continue;\n      }\n    }\n    \n    // No price found, assume free mint\n    return { mintPrice: BigInt(0), totalCost: BigInt(0) };\n  }\n}",
      "type": "registry:lib"
    },
    {
      "path": "registry/mini-app/blocks/nft-mint-flow/lib/mint-reducer.ts",
      "content": "import type { NFTContractInfo } from \"./types\";\n\nexport type MintStep = \"initial\" | \"detecting\" | \"sheet\" | \"connecting\" | \"approve\" | \"approving\" | \"minting\" | \"waiting\" | \"success\" | \"error\" | \"validation-error\";\n\nexport type TransactionType = \"approval\" | \"mint\" | null;\n\nexport type MintState = {\n  step: MintStep;\n  contractInfo: NFTContractInfo | null;\n  priceData: {\n    mintPrice?: bigint;\n    totalCost: bigint;\n    erc20Details?: {\n      address: string;\n      symbol: string;\n      decimals: number;\n      allowance?: bigint;\n      needsApproval?: boolean;\n    };\n  };\n  error?: string;\n  txHash?: string;\n  txType: TransactionType;\n  isLoading: boolean;\n  validationErrors: string[];\n};\n\nexport const initialState: MintState = {\n  step: \"initial\",\n  contractInfo: null,\n  priceData: { totalCost: BigInt(0) },\n  error: undefined,\n  txHash: undefined,\n  txType: null,\n  isLoading: false,\n  validationErrors: []\n};\n\nexport type MintAction = \n  | { type: \"DETECT_START\" }\n  | { type: \"DETECT_SUCCESS\"; payload: { contractInfo: NFTContractInfo; priceData: MintState[\"priceData\"] } }\n  | { type: \"DETECT_ERROR\"; payload: string }\n  | { type: \"VALIDATION_ERROR\"; payload: string[] }\n  | { type: \"APPROVE_REQUIRED\" }\n  | { type: \"APPROVE_START\" }\n  | { type: \"APPROVE_TX_SUBMITTED\"; payload: string }\n  | { type: \"APPROVE_SUCCESS\" }\n  | { type: \"CONNECT_START\" }\n  | { type: \"CONNECT_SUCCESS\" }\n  | { type: \"MINT_START\" }\n  | { type: \"MINT_TX_SUBMITTED\"; payload: string }\n  | { type: \"TX_SUCCESS\"; payload: string }\n  | { type: \"TX_ERROR\"; payload: string }\n  | { type: \"RESET\" }\n  | { type: \"UPDATE_ALLOWANCE\"; payload: bigint };\n\nexport function mintReducer(state: MintState, action: MintAction): MintState {\n  switch (action.type) {\n    case \"DETECT_START\":\n      return { ...state, step: \"detecting\", isLoading: true, error: undefined };\n      \n    case \"DETECT_SUCCESS\":\n      // Check if approval is needed based on allowance\n      const needsApproval = action.payload.priceData.erc20Details && \n        action.payload.contractInfo.claim &&\n        (action.payload.priceData.erc20Details.allowance !== undefined) &&\n        (action.payload.priceData.erc20Details.allowance < action.payload.contractInfo.claim.cost);\n        \n      return {\n        ...state,\n        step: needsApproval ? \"approve\" : \"sheet\",\n        contractInfo: action.payload.contractInfo,\n        priceData: {\n          ...action.payload.priceData,\n          erc20Details: action.payload.priceData.erc20Details ? {\n            ...action.payload.priceData.erc20Details,\n            needsApproval\n          } : undefined\n        },\n        isLoading: false\n      };\n      \n    case \"DETECT_ERROR\":\n      return { ...state, step: \"error\", error: action.payload, isLoading: false };\n      \n    case \"VALIDATION_ERROR\":\n      return { ...state, step: \"validation-error\", validationErrors: action.payload, isLoading: false };\n      \n    case \"APPROVE_REQUIRED\":\n      return { ...state, step: \"approve\" };\n      \n    case \"APPROVE_START\":\n      return { ...state, step: \"approving\", isLoading: true, txType: \"approval\" };\n      \n    case \"APPROVE_TX_SUBMITTED\":\n      return { ...state, step: \"waiting\", txHash: action.payload, txType: \"approval\" };\n      \n    case \"APPROVE_SUCCESS\":\n      return { \n        ...state, \n        step: \"sheet\", \n        isLoading: false,\n        txType: null,\n        txHash: undefined, // Clear tx hash after approval\n        priceData: {\n          ...state.priceData,\n          erc20Details: state.priceData.erc20Details ? {\n            ...state.priceData.erc20Details,\n            needsApproval: false,\n            allowance: state.contractInfo?.claim?.cost || BigInt(0)\n          } : undefined\n        }\n      };\n      \n    case \"CONNECT_START\":\n      return { ...state, step: \"connecting\" };\n      \n    case \"CONNECT_SUCCESS\":\n      return { ...state, step: \"sheet\" };\n      \n    case \"MINT_START\":\n      return { ...state, step: \"minting\", isLoading: true, txType: \"mint\" };\n      \n    case \"MINT_TX_SUBMITTED\":\n      return { ...state, step: \"waiting\", txHash: action.payload, txType: \"mint\" };\n      \n    case \"TX_SUCCESS\":\n      // Only show success for mint transactions\n      return state.txType === \"mint\" \n        ? { ...state, step: \"success\", txHash: action.payload, isLoading: false, txType: null }\n        : state;\n      \n    case \"TX_ERROR\":\n      return { ...state, step: \"error\", error: action.payload, isLoading: false, txType: null };\n      \n    case \"UPDATE_ALLOWANCE\":\n      if (!state.priceData.erc20Details) return state;\n      \n      const updatedNeedsApproval = state.contractInfo?.claim \n        ? action.payload < state.contractInfo.claim.cost\n        : false;\n        \n      return {\n        ...state,\n        priceData: {\n          ...state.priceData,\n          erc20Details: {\n            ...state.priceData.erc20Details,\n            allowance: action.payload,\n            needsApproval: updatedNeedsApproval\n          }\n        }\n      };\n      \n    case \"RESET\":\n      return initialState;\n      \n    default:\n      return state;\n  }\n}",
      "type": "registry:lib"
    },
    {
      "path": "registry/mini-app/blocks/nft-mint-flow/lib/error-parser.ts",
      "content": "export type ErrorType = \n  | \"insufficient-funds\"\n  | \"wrong-network\" \n  | \"user-rejected\"\n  | \"contract-error\"\n  | \"allowance-error\"\n  | \"network-error\"\n  | \"unknown\";\n\nexport interface ParsedError {\n  type: ErrorType;\n  message: string;\n  details?: string;\n  actionText?: string;\n  action?: () => void;\n}\n\n/**\n * Parse blockchain errors into user-friendly messages with actionable next steps\n */\nexport function parseError(error: unknown, context: \"approval\" | \"mint\"): ParsedError {\n  const errorMessage = error instanceof Error ? error.message.toLowerCase() : String(error).toLowerCase();\n  \n  // User rejected transaction\n  if (errorMessage.includes(\"user rejected\") || errorMessage.includes(\"user denied\")) {\n    return {\n      type: \"user-rejected\",\n      message: \"Transaction cancelled\",\n      details: \"You rejected the transaction in your wallet\",\n      actionText: \"Try again\"\n    };\n  }\n  \n  // Insufficient funds\n  if (\n    errorMessage.includes(\"insufficient funds\") ||\n    errorMessage.includes(\"insufficient balance\") ||\n    errorMessage.includes(\"not enough\") ||\n    errorMessage.includes(\"exceeds balance\")\n  ) {\n    return {\n      type: \"insufficient-funds\",\n      message: \"Insufficient funds\",\n      details: context === \"approval\" \n        ? \"You don't have enough tokens to approve this amount\"\n        : \"You don't have enough funds to complete this transaction. Check both token balance and ETH for gas.\",\n      actionText: \"Check wallet balance\"\n    };\n  }\n  \n  // Wrong network\n  if (\n    errorMessage.includes(\"network\") ||\n    errorMessage.includes(\"chain\") ||\n    errorMessage.includes(\"chainid\")\n  ) {\n    return {\n      type: \"wrong-network\",\n      message: \"Wrong network\",\n      details: \"Please switch to the correct network in your wallet\",\n      actionText: \"Switch network\"\n    };\n  }\n  \n  // Contract errors\n  if (\n    errorMessage.includes(\"revert\") ||\n    errorMessage.includes(\"execution reverted\") ||\n    errorMessage.includes(\"contract error\")\n  ) {\n    // Try to extract revert reason\n    let details = \"The contract rejected this transaction.\";\n    \n    if (errorMessage.includes(\"sold out\") || errorMessage.includes(\"max supply\")) {\n      details = \"This NFT is sold out or has reached maximum supply.\";\n    } else if (errorMessage.includes(\"not started\") || errorMessage.includes(\"not active\")) {\n      details = \"Minting hasn't started yet or has ended.\";\n    } else if (errorMessage.includes(\"max per wallet\") || errorMessage.includes(\"exceeds max\")) {\n      details = \"You've reached the maximum amount allowed per wallet.\";\n    } else if (errorMessage.includes(\"allowlist\") || errorMessage.includes(\"not eligible\")) {\n      details = \"You're not eligible to mint this NFT. Check if it requires an allowlist.\";\n    }\n    \n    return {\n      type: \"contract-error\",\n      message: \"Transaction failed\",\n      details,\n      actionText: \"Try again later\"\n    };\n  }\n  \n  // Allowance errors\n  if (errorMessage.includes(\"allowance\") || errorMessage.includes(\"approve\")) {\n    return {\n      type: \"allowance-error\",\n      message: \"Approval required\",\n      details: \"You need to approve the contract to spend your tokens first\",\n      actionText: \"Approve tokens\"\n    };\n  }\n  \n  // Network/RPC errors\n  if (\n    errorMessage.includes(\"timeout\") ||\n    errorMessage.includes(\"network\") ||\n    errorMessage.includes(\"fetch\") ||\n    errorMessage.includes(\"rpc\")\n  ) {\n    return {\n      type: \"network-error\",\n      message: \"Network error\",\n      details: \"Connection issue with the blockchain. This is usually temporary.\",\n      actionText: \"Try again\"\n    };\n  }\n  \n  // Generic fallback\n  return {\n    type: \"unknown\",\n    message: \"Transaction failed\",\n    details: error instanceof Error ? error.message : \"An unexpected error occurred\",\n    actionText: \"Try again\"\n  };\n}",
      "type": "registry:lib"
    },
    {
      "path": "registry/mini-app/blocks/nft-card/nft-card.tsx",
      "content": "\"use client\";\n\nimport { cn } from \"@/registry/mini-app/lib/utils\";\nimport Image from \"next/image\";\nimport { useState, useEffect, useRef } from \"react\";\n\ninterface NFTMetadata {\n  name?: string;\n  description?: string;\n  image?: string;\n  image_url?: string;\n  external_url?: string;\n  attributes?: Array<{\n    trait_type: string;\n    value: string | number;\n    display_type?: string;\n  }>;\n  image_details?: {\n    bytes?: number;\n    format?: string;\n    sha256?: string;\n    width?: number;\n    height?: number;\n  };\n  [key: string]: unknown;\n}\nimport { getAddress, type Address } from \"viem\";\nimport { \n  findChainByName, \n  getPublicClient \n} from \"@/registry/mini-app/lib/chains\";\nimport { \n  ERC721_ABI, \n  ipfsToHttp \n} from \"@/registry/mini-app/lib/nft-standards\";\nimport { \n  getTokenURIWithManifoldSupport \n} from \"@/registry/mini-app/lib/manifold-utils\";\n\n// Base64 placeholder image\nconst PLACEHOLDER_IMAGE =\n  \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAwIiBoZWlnaHQ9IjMwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMzAwIiBoZWlnaHQ9IjMwMCIgZmlsbD0iI2YxZjFmMSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwsIHNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMjQiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGRvbWluYW50LWJhc2VsaW5lPSJtaWRkbGUiIGZpbGw9IiM5OTkiPk5GVCBJbWFnZTwvdGV4dD48L3N2Zz4=\";\n\n\ntype NFTCardProps = {\n  contractAddress: string;\n  tokenId: string;\n  network?: string;\n  alt?: string;\n  className?: string;\n  width?: number;\n  height?: number;\n  rounded?: \"none\" | \"sm\" | \"md\" | \"lg\" | \"xl\" | \"full\";\n  shadow?: boolean;\n  objectFit?: \"contain\" | \"cover\" | \"fill\";\n  fallbackImageUrl?: string;\n  showTitle?: boolean;\n  showNetwork?: boolean;\n  titlePosition?: \"top\" | \"bottom\" | \"outside\";\n  networkPosition?:\n    | \"top-left\"\n    | \"top-right\"\n    | \"bottom-left\"\n    | \"bottom-right\"\n    | \"outside\";\n  customTitle?: string;\n  customNetworkName?: string;\n  loadingComponent?: React.ReactNode;\n  errorComponent?: React.ReactNode;\n  imageProps?: React.ComponentProps<typeof Image>;\n  titleClassName?: string;\n  networkClassName?: string;\n  showOwner?: boolean;\n  onLoad?: (metadata: NFTMetadata) => void;\n  onError?: (error: Error) => void;\n  layout?: \"compact\" | \"card\" | \"detailed\";\n  containerClassName?: string;\n};\n\nexport function NFTCard({\n  contractAddress,\n  tokenId,\n  network = \"ethereum\", // Default to Ethereum mainnet\n  alt = \"NFT Image\",\n  className = \"\",\n  width = 300,\n  height = 300,\n  rounded = \"md\",\n  shadow = true,\n  objectFit = \"cover\",\n  fallbackImageUrl = PLACEHOLDER_IMAGE,\n  showTitle = true,\n  showNetwork = true,\n  titlePosition = \"outside\",\n  networkPosition = \"top-right\",\n  customTitle,\n  customNetworkName,\n  loadingComponent,\n  errorComponent,\n  imageProps,\n  titleClassName = \"\",\n  networkClassName = \"\",\n  showOwner = false,\n  onLoad,\n  onError,\n  layout = \"card\",\n  containerClassName = \"\",\n}: NFTCardProps) {\n  const [imageUrl, setImageUrl] = useState<string>(fallbackImageUrl);\n  const [isLoading, setIsLoading] = useState<boolean>(true);\n  const [error, setError] = useState<string | null>(null);\n  const [title, setTitle] = useState<string | null>(customTitle || null);\n  const [networkName, setNetworkName] = useState<string>(\n    customNetworkName || \"\",\n  );\n  const [owner, setOwner] = useState<string | null>(null);\n  const [metadata, setMetadata] = useState<NFTMetadata | null>(null);\n  const abortControllerRef = useRef<AbortController | null>(null);\n\n  const roundedClasses = {\n    none: \"rounded-none\",\n    sm: \"rounded-sm\",\n    md: \"rounded-md\",\n    lg: \"rounded-lg\",\n    xl: \"rounded-xl\",\n    full: \"rounded-full\",\n  };\n\n  const networkPositionClasses = {\n    \"top-left\": \"top-0 left-0 rounded-br-md\",\n    \"top-right\": \"top-0 right-0 rounded-bl-md\",\n    \"bottom-left\": \"bottom-0 left-0 rounded-tr-md\",\n    \"bottom-right\": \"bottom-0 right-0 rounded-tl-md\",\n    outside: \"\",\n  };\n\n  useEffect(() => {\n    if (customTitle) {\n      setTitle(customTitle);\n    }\n\n    if (customNetworkName) {\n      setNetworkName(customNetworkName);\n    }\n  }, [customTitle, customNetworkName]);\n\n  useEffect(() => {\n    const fetchNFTData = async () => {\n      if (!contractAddress || !tokenId) return;\n      \n      // Cancel any previous request\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n      \n      // Create new AbortController for this request\n      const abortController = new AbortController();\n      abortControllerRef.current = abortController;\n\n      setIsLoading(true);\n      setError(null);\n\n      try {\n        // Skip chain setup if we have customNetworkName\n        if (!customNetworkName) {\n          // Find the chain by name using shared utility\n          const selectedChain = findChainByName(network || \"ethereum\");\n          \n          if (!selectedChain) {\n            console.warn(\n              `Chain \"${network}\" not found, defaulting to Ethereum mainnet`,\n            );\n            setNetworkName(\"Ethereum\");\n          } else {\n            setNetworkName(selectedChain.name);\n          }\n\n          // Create public client using shared utility\n          const client = getPublicClient(selectedChain?.id || 1);\n\n          console.log(\n            `Fetching NFT data from ${selectedChain?.name || 'Ethereum'} for contract ${contractAddress} token ${tokenId}`,\n          );\n\n          // Skip title setup if we have customTitle\n          if (!customTitle) {\n            try {\n              // Get contract name\n              const name = (await client.readContract({\n                address: getAddress(contractAddress),\n                abi: ERC721_ABI.name,\n                functionName: \"name\",\n              })) as string;\n\n              // Set title\n              setTitle(`${name} #${tokenId}`);\n            } catch (nameError) {\n              console.warn(\"Could not fetch NFT name:\", nameError);\n              setTitle(`NFT #${tokenId}`);\n            }\n          }\n\n          // Get owner if requested\n          if (showOwner) {\n            try {\n              const ownerAddress = (await client.readContract({\n                address: getAddress(contractAddress),\n                abi: ERC721_ABI.ownerOf,\n                functionName: \"ownerOf\",\n                args: [BigInt(tokenId)],\n              })) as string;\n\n              setOwner(ownerAddress);\n            } catch (ownerError) {\n              console.warn(\"Could not fetch NFT owner:\", ownerError);\n            }\n          }\n\n          // Get tokenURI with automatic Manifold support\n          let metadataUrl = await getTokenURIWithManifoldSupport(\n            client,\n            getAddress(contractAddress) as Address,\n            tokenId\n          );\n\n          // Handle IPFS URLs using shared utility\n          metadataUrl = ipfsToHttp(metadataUrl);\n\n          // Fetch metadata with abort signal\n          const response = await fetch(metadataUrl, {\n            signal: abortController.signal\n          });\n          \n          if (!response.ok) {\n            throw new Error(`Failed to fetch metadata: ${response.status}`);\n          }\n          \n          const fetchedMetadata = await response.json();\n          console.log(\"NFT metadata:\", fetchedMetadata);\n          \n          // Store metadata in state\n          setMetadata(fetchedMetadata);\n\n          // Call onLoad callback if provided\n          if (onLoad) {\n            onLoad(fetchedMetadata);\n          }\n\n          // Get image URL from metadata\n          let nftImageUrl = fetchedMetadata.image || fetchedMetadata.image_url;\n\n          // Handle IPFS URLs for image using shared utility\n          if (nftImageUrl) {\n            nftImageUrl = ipfsToHttp(nftImageUrl);\n          }\n\n          if (nftImageUrl) {\n            setImageUrl(nftImageUrl);\n          } else {\n            // If no image URL found, use placeholder\n            setImageUrl(fallbackImageUrl);\n          }\n        }\n      } catch (err) {\n        // Don't update state if request was aborted\n        if (err instanceof Error && err.name === 'AbortError') {\n          console.log('NFT data fetch was cancelled');\n          return;\n        }\n        \n        console.error(\"Error fetching NFT:\", err);\n        const error = err instanceof Error ? err : new Error(String(err));\n        setError(`Failed to load NFT data: ${error.message}`);\n        setImageUrl(fallbackImageUrl);\n\n        // Call onError callback if provided\n        if (onError) {\n          onError(error);\n        }\n      } finally {\n        // Only update loading state if this request wasn't aborted\n        if (!abortController.signal.aborted) {\n          setIsLoading(false);\n        }\n      }\n    };\n\n    fetchNFTData();\n    \n    // Cleanup function to abort request if component unmounts or deps change\n    return () => {\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n    };\n  }, [\n    contractAddress,\n    tokenId,\n    network,\n    fallbackImageUrl,\n    customTitle,\n    customNetworkName,\n    showOwner,\n    onLoad,\n    onError,\n  ]);\n\n  const defaultLoadingComponent = (\n    <div className=\"absolute inset-0 flex items-center justify-center bg-gray-300 dark:bg-gray-700\">\n      <div className=\"w-full h-full bg-gray-200 dark:bg-gray-800 animate-pulse\"></div>\n    </div>\n  );\n\n  const defaultErrorComponent = (\n    <div className=\"absolute inset-0 flex items-center justify-center bg-gray-100 dark:bg-gray-800\">\n      <p className=\"text-red-500 text-sm text-center px-2\">{error}</p>\n    </div>\n  );\n\n  // Render network badge inside the image\n  const renderNetworkBadge = () => {\n    if (!showNetwork || !networkName || networkPosition === \"outside\")\n      return null;\n\n    return (\n      <div\n        className={cn(\n          \"absolute bg-black/60 px-2 py-1 text-white text-xs\",\n          networkPositionClasses[networkPosition],\n          networkClassName,\n        )}\n      >\n        {networkName}\n      </div>\n    );\n  };\n\n  // Render title inside the image\n  const renderInnerTitle = () => {\n    if (!showTitle || !title || titlePosition === \"outside\") return null;\n\n    return (\n      <div\n        className={cn(\n          \"absolute left-0 right-0 bg-black/60 p-2 text-white text-sm truncate\",\n          titlePosition === \"top\" ? \"top-0\" : \"bottom-0\",\n          titleClassName,\n        )}\n      >\n        {title}\n        {showOwner && owner && (\n          <div className=\"text-xs opacity-70 truncate\">\n            Owner: {owner.substring(0, 6)}...{owner.substring(owner.length - 4)}\n          </div>\n        )}\n      </div>\n    );\n  };\n\n  // Render outside information (title, network, owner)\n  const renderOutsideInfo = () => {\n    if (\n      (!showTitle || !title) &&\n      (!showNetwork || !networkName || networkPosition !== \"outside\") &&\n      (!showOwner || !owner || titlePosition !== \"outside\")\n    ) {\n      return null;\n    }\n\n    return (\n      <div className=\"mt-2\">\n        {showTitle && title && titlePosition === \"outside\" && (\n          <div className={cn(\"text-sm font-medium truncate\", titleClassName)}>\n            {title}\n          </div>\n        )}\n\n        {showNetwork && networkName && networkPosition === \"outside\" && (\n          <div\n            className={cn(\n              \"text-xs text-gray-500 dark:text-gray-400\",\n              networkClassName,\n            )}\n          >\n            Network: {networkName}\n          </div>\n        )}\n\n        {showOwner && owner && titlePosition === \"outside\" && (\n          <div className=\"text-xs text-gray-500 dark:text-gray-400 truncate\">\n            Owner: {owner.substring(0, 6)}...{owner.substring(owner.length - 4)}\n          </div>\n        )}\n      </div>\n    );\n  };\n\n  // Apply different layouts\n  const getContainerClasses = () => {\n    switch (layout) {\n      case \"compact\":\n        return \"inline-block\";\n      case \"detailed\":\n        return \"flex flex-col overflow-hidden\";\n      case \"card\":\n      default:\n        return \"\";\n    }\n  };\n\n  // Calculate display dimensions that preserve aspect ratio\n  const getDisplayDimensions = () => {\n    const maxWidth = width || 300;\n    const maxHeight = height || 300;\n    \n    // Check if we have image_details with dimensions\n    if (metadata?.image_details?.width && metadata?.image_details?.height) {\n      const originalAspectRatio = metadata.image_details.width / metadata.image_details.height;\n      \n      // Scale to fit within bounds while preserving aspect ratio\n      const widthBasedHeight = maxWidth / originalAspectRatio;\n      const heightBasedWidth = maxHeight * originalAspectRatio;\n      \n      if (widthBasedHeight <= maxHeight) {\n        // Width is the limiting factor\n        return { \n          width: maxWidth, \n          height: Math.round(widthBasedHeight),\n          useContain: true // Use contain to show full image\n        };\n      } else {\n        // Height is the limiting factor\n        return { \n          width: Math.round(heightBasedWidth), \n          height: maxHeight,\n          useContain: true\n        };\n      }\n    }\n    \n    // No image_details, use provided dimensions\n    return { width: maxWidth, height: maxHeight, useContain: false };\n  };\n\n  const displayDimensions = getDisplayDimensions();\n\n  return (\n    <div className={cn(getContainerClasses(), containerClassName)}>\n      <div\n        className={cn(\n          \"relative overflow-hidden\",\n          roundedClasses[rounded],\n          shadow && \"shadow-md\",\n          className,\n        )}\n        style={{ \n          width: `${displayDimensions.width}px`, \n          height: `${displayDimensions.height}px` \n        }}\n      >\n        {isLoading && (loadingComponent || defaultLoadingComponent)}\n\n        {error && (errorComponent || defaultErrorComponent)}\n\n        <Image\n          src={imageUrl}\n          alt={alt}\n          fill={true}\n          className={cn(\n            displayDimensions.useContain ? \"object-contain\" : `object-${objectFit}`,\n            isLoading && \"opacity-0\"\n          )}\n          unoptimized={true}\n          onError={() => setImageUrl(PLACEHOLDER_IMAGE)}\n          {...imageProps}\n        />\n\n        {renderInnerTitle()}\n        {renderNetworkBadge()}\n      </div>\n\n      {renderOutsideInfo()}\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": ""
    },
    {
      "path": "registry/mini-app/lib/utils.ts",
      "content": "import { clsx, type ClassValue } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}",
      "type": "registry:lib",
      "target": ""
    },
    {
      "path": "registry/mini-app/lib/chains.ts",
      "content": "import { http, type Chain, type PublicClient, createPublicClient } from \"viem\";\nimport * as chains from \"viem/chains\";\n\n/**\n * Centralized chain configuration with Alchemy RPC support\n * Maps chain IDs to their Alchemy subdomain prefixes\n */\nexport const ALCHEMY_CHAIN_CONFIGS: Record<number, { name: string; url: string | null }> = {\n  1: { name: 'ethereum', url: 'eth-mainnet' },\n  10: { name: 'optimism', url: 'opt-mainnet' },\n  137: { name: 'polygon', url: 'polygon-mainnet' },\n  8453: { name: 'base', url: 'base-mainnet' },\n  42161: { name: 'arbitrum', url: 'arb-mainnet' },\n  7777777: { name: 'zora', url: null }, // No Alchemy support\n} as const;\n\n/**\n * Get viem Chain object by ID\n */\nexport function getChainById(chainId: number): Chain {\n  switch (chainId) {\n    case 1:\n      return chains.mainnet;\n    case 10:\n      return chains.optimism;\n    case 137:\n      return chains.polygon;\n    case 8453:\n      return chains.base;\n    case 42161:\n      return chains.arbitrum;\n    case 7777777:\n      return chains.zora;\n    default:\n      // Try to find in all chains\n      const chain = Object.values(chains).find(\n        (c) => typeof c === 'object' && c !== null && 'id' in c && (c as any).id === chainId\n      ) as Chain | undefined;\n      return chain || chains.mainnet;\n  }\n}\n\n/**\n * Get HTTP transport with optional Alchemy RPC URL\n * Falls back to public RPC if no Alchemy key is available\n */\nexport function getTransport(chainId: number) {\n  const alchemyKey = process.env.NEXT_PUBLIC_ALCHEMY_KEY;\n  const config = ALCHEMY_CHAIN_CONFIGS[chainId];\n  \n  if (config?.url && alchemyKey) {\n    return http(`https://${config.url}.g.alchemy.com/v2/${alchemyKey}`);\n  }\n  \n  // Fallback to default public RPC\n  return http();\n}\n\n/**\n * Create a public client for a specific chain with optimal transport\n */\nexport function getPublicClient(chainId: number): PublicClient {\n  return createPublicClient({\n    chain: getChainById(chainId),\n    transport: getTransport(chainId),\n  }) as PublicClient;\n}\n\n/**\n * Get all available chains mapped by normalized name\n */\nexport function getAvailableChains(): Record<string, Chain> {\n  const availableChains: Record<string, Chain> = {};\n  \n  Object.entries(chains).forEach(([name, chain]) => {\n    if (typeof chain === \"object\" && chain !== null && \"id\" in chain) {\n      availableChains[name.toLowerCase()] = chain as Chain;\n    }\n  });\n  \n  return availableChains;\n}\n\n/**\n * Find chain by network name (fuzzy match)\n */\nexport function findChainByName(networkName: string): Chain | undefined {\n  const normalizedName = networkName.toLowerCase().replace(/[\\s-]/g, \"\");\n  const availableChains = getAvailableChains();\n  \n  // Try exact match first\n  if (availableChains[normalizedName]) {\n    return availableChains[normalizedName];\n  }\n  \n  // Try partial match\n  const matchingChainName = Object.keys(availableChains).find(\n    (chainName) =>\n      chainName.includes(normalizedName) ||\n      normalizedName.includes(chainName)\n  );\n  \n  return matchingChainName ? availableChains[matchingChainName] : undefined;\n}",
      "type": "registry:lib",
      "target": ""
    },
    {
      "path": "registry/mini-app/lib/nft-standards.ts",
      "content": "import { parseAbi, type Address } from \"viem\";\n\n/**\n * Common NFT contract ABIs and standards\n */\n\n// Standard ERC721 functions\nexport const ERC721_ABI = {\n  full: parseAbi([\n    \"function tokenURI(uint256 tokenId) view returns (string)\",\n    \"function name() view returns (string)\",\n    \"function symbol() view returns (string)\",\n    \"function ownerOf(uint256 tokenId) view returns (address)\",\n    \"function balanceOf(address owner) view returns (uint256)\",\n    \"function totalSupply() view returns (uint256)\",\n  ]),\n  \n  // Individual functions for specific use cases\n  tokenURI: parseAbi([\"function tokenURI(uint256 tokenId) view returns (string)\"]),\n  name: parseAbi([\"function name() view returns (string)\"]),\n  symbol: parseAbi([\"function symbol() view returns (string)\"]),\n  ownerOf: parseAbi([\"function ownerOf(uint256 tokenId) view returns (address)\"]),\n};\n\n// Common price discovery functions across NFT contracts\nexport const PRICE_DISCOVERY_ABI = parseAbi([\n  \"function mintPrice() view returns (uint256)\",\n  \"function price() view returns (uint256)\",\n  \"function MINT_PRICE() view returns (uint256)\",\n  \"function getMintPrice() view returns (uint256)\",\n  \"function publicMintPrice() view returns (uint256)\",\n]);\n\n// Common mint functions\nexport const MINT_ABI = parseAbi([\n  \"function mint(uint256 amount) payable\",\n  \"function mint(address to, uint256 amount) payable\",\n  \"function publicMint(uint256 amount) payable\",\n  \"function mintTo(address to, uint256 amount) payable\",\n]);\n\n// ERC20 ABI for token interactions\nexport const ERC20_ABI = parseAbi([\n  \"function decimals() view returns (uint8)\",\n  \"function symbol() view returns (string)\",\n  \"function name() view returns (string)\",\n  \"function totalSupply() view returns (uint256)\",\n  \"function balanceOf(address owner) view returns (uint256)\",\n  \"function allowance(address owner, address spender) view returns (uint256)\",\n  \"function approve(address spender, uint256 value) returns (bool)\",\n  \"function transfer(address to, uint256 value) returns (bool)\",\n  \"function transferFrom(address from, address to, uint256 value) returns (bool)\",\n]);\n\n// Manifold contract detection ABI (kept separate as it's used on the main contract)\nexport const MANIFOLD_DETECTION_ABI = parseAbi([\n  \"function getExtensions() view returns (address[])\",\n]);\n\n// Manifold extension contract full ABI\nexport const MANIFOLD_EXTENSION_ABI = [\n  {\n    inputs: [\n      { name: \"creatorContractAddress\", type: \"address\" },\n      { name: \"tokenId\", type: \"uint256\" }\n    ],\n    name: \"tokenURI\",\n    outputs: [{ name: \"uri\", type: \"string\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { name: \"creatorContractAddress\", type: \"address\" },\n      { name: \"instanceId\", type: \"uint256\" }\n    ],\n    name: \"getClaim\",\n    outputs: [\n      {\n        components: [\n          { name: \"total\", type: \"uint32\" },\n          { name: \"totalMax\", type: \"uint32\" },\n          { name: \"walletMax\", type: \"uint32\" },\n          { name: \"startDate\", type: \"uint48\" },\n          { name: \"endDate\", type: \"uint48\" },\n          { name: \"storageProtocol\", type: \"uint8\" },\n          { name: \"merkleRoot\", type: \"bytes32\" },\n          { name: \"location\", type: \"string\" },\n          { name: \"tokenId\", type: \"uint256\" },\n          { name: \"cost\", type: \"uint256\" },\n          { name: \"paymentReceiver\", type: \"address\" },\n          { name: \"erc20\", type: \"address\" },\n          { name: \"signingAddress\", type: \"address\" }\n        ],\n        name: \"claim\",\n        type: \"tuple\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { name: \"creatorContractAddress\", type: \"address\" },\n      { name: \"tokenId\", type: \"uint256\" }\n    ],\n    name: \"getClaimForToken\",\n    outputs: [\n      { name: \"instanceId\", type: \"uint256\" },\n      {\n        components: [\n          { name: \"total\", type: \"uint32\" },\n          { name: \"totalMax\", type: \"uint32\" },\n          { name: \"walletMax\", type: \"uint32\" },\n          { name: \"startDate\", type: \"uint48\" },\n          { name: \"endDate\", type: \"uint48\" },\n          { name: \"storageProtocol\", type: \"uint8\" },\n          { name: \"merkleRoot\", type: \"bytes32\" },\n          { name: \"location\", type: \"string\" },\n          { name: \"tokenId\", type: \"uint256\" },\n          { name: \"cost\", type: \"uint256\" },\n          { name: \"paymentReceiver\", type: \"address\" },\n          { name: \"erc20\", type: \"address\" },\n          { name: \"signingAddress\", type: \"address\" }\n        ],\n        name: \"claim\",\n        type: \"tuple\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { name: \"creatorContractAddress\", type: \"address\" },\n      { name: \"instanceId\", type: \"uint256\" },\n      { name: \"mintIndex\", type: \"uint32\" },\n      { name: \"merkleProof\", type: \"bytes32[]\" },\n      { name: \"mintFor\", type: \"address\" }\n    ],\n    name: \"mint\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"MINT_FEE\",\n    outputs: [{ name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"MINT_FEE_MERKLE\",\n    outputs: [{ name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  }\n] as const;\n\n// ERC165 interface detection\nexport const ERC165_ABI = parseAbi([\n  \"function supportsInterface(bytes4 interfaceId) view returns (bool)\",\n]);\n\n// Known contract addresses\nexport const KNOWN_CONTRACTS = {\n  // Manifold extension contracts\n  manifoldExtension: \"0x26BBEA7803DcAc346D5F5f135b57Cf2c752A02bE\" as Address,\n  \n  // Add other known contracts here as needed\n} as const;\n\n// Interface IDs for contract detection\nexport const INTERFACE_IDS = {\n  ERC165: \"0x01ffc9a7\",\n  ERC721: \"0x80ac58cd\",\n  ERC1155: \"0xd9b67a26\",\n  ERC721Metadata: \"0x5b5e139f\",\n} as const;\n\n// IPFS Gateway configuration\nexport const IPFS_GATEWAYS = {\n  default: \"https://ipfs.io/ipfs/\",\n  cloudflare: \"https://cloudflare-ipfs.com/ipfs/\",\n  pinata: \"https://gateway.pinata.cloud/ipfs/\",\n} as const;\n\n/**\n * Convert IPFS URL to HTTP gateway URL\n */\nexport function ipfsToHttp(url: string, gateway: keyof typeof IPFS_GATEWAYS = 'default'): string {\n  if (!url || !url.startsWith('ipfs://')) {\n    return url;\n  }\n  \n  return url.replace('ipfs://', IPFS_GATEWAYS[gateway]);\n}\n\n/**\n * Check if a contract is likely an NFT contract by checking interface support\n */\nexport async function isNFTContract(\n  client: any,\n  contractAddress: Address\n): Promise<{ isNFT: boolean; type?: 'ERC721' | 'ERC1155' }> {\n  try {\n    // Try ERC165 supportsInterface\n    const [supportsERC721, supportsERC1155] = await Promise.all([\n      client.readContract({\n        address: contractAddress,\n        abi: ERC165_ABI,\n        functionName: 'supportsInterface',\n        args: [INTERFACE_IDS.ERC721],\n      }).catch(() => false),\n      client.readContract({\n        address: contractAddress,\n        abi: ERC165_ABI,\n        functionName: 'supportsInterface',\n        args: [INTERFACE_IDS.ERC1155],\n      }).catch(() => false),\n    ]);\n    \n    if (supportsERC721) return { isNFT: true, type: 'ERC721' };\n    if (supportsERC1155) return { isNFT: true, type: 'ERC1155' };\n    \n    // Fallback: try to call name() function\n    const name = await client.readContract({\n      address: contractAddress,\n      abi: ERC721_ABI.name,\n      functionName: 'name',\n    }).catch(() => null);\n    \n    return { isNFT: !!name };\n  } catch {\n    return { isNFT: false };\n  }\n}",
      "type": "registry:lib",
      "target": ""
    },
    {
      "path": "registry/mini-app/lib/manifold-utils.ts",
      "content": "import { type Address, type PublicClient, getAddress } from \"viem\";\nimport { MANIFOLD_DETECTION_ABI, MANIFOLD_EXTENSION_ABI, KNOWN_CONTRACTS, ERC721_ABI } from \"./nft-standards\";\n\n/**\n * Manifold contract utilities\n */\n\nexport interface ManifoldDetectionResult {\n  isManifold: boolean;\n  extensionAddress?: Address;\n  extensions?: Address[];\n}\n\nexport interface ManifoldClaim {\n  total: number;\n  totalMax: number;\n  walletMax: number;\n  startDate: bigint;\n  endDate: bigint;\n  storageProtocol: number;\n  merkleRoot: `0x${string}`;\n  location: string;\n  tokenId: bigint;\n  cost: bigint;\n  paymentReceiver: Address;\n  erc20: Address;\n  signingAddress: Address;\n}\n\n/**\n * Detect if a contract is a Manifold contract with extensions\n */\nexport async function detectManifoldContract(\n  client: PublicClient,\n  contractAddress: Address\n): Promise<ManifoldDetectionResult> {\n  try {\n    const extensions = await client.readContract({\n      address: getAddress(contractAddress),\n      abi: MANIFOLD_DETECTION_ABI,\n      functionName: \"getExtensions\",\n    }) as Address[];\n    \n    if (!extensions || extensions.length === 0) {\n      return { isManifold: false };\n    }\n    \n    // Check if it has the known Manifold extension\n    const knownExtension = extensions.find(\n      ext => ext.toLowerCase() === KNOWN_CONTRACTS.manifoldExtension.toLowerCase()\n    );\n    \n    return {\n      isManifold: true,\n      extensionAddress: knownExtension || extensions[0],\n      extensions,\n    };\n  } catch {\n    return { isManifold: false };\n  }\n}\n\n/**\n * Get token URI for a Manifold NFT\n */\nexport async function getManifoldTokenURI(\n  client: PublicClient,\n  contractAddress: Address,\n  tokenId: string,\n  extensionAddress?: Address\n): Promise<string> {\n  const extension = extensionAddress || KNOWN_CONTRACTS.manifoldExtension;\n  \n  return await client.readContract({\n    address: getAddress(extension),\n    abi: MANIFOLD_EXTENSION_ABI,\n    functionName: \"tokenURI\",\n    args: [getAddress(contractAddress), BigInt(tokenId)],\n  }) as string;\n}\n\n/**\n * Get token URI with automatic Manifold detection\n */\nexport async function getTokenURIWithManifoldSupport(\n  client: PublicClient,\n  contractAddress: Address,\n  tokenId: string\n): Promise<string> {\n  // Try Manifold first\n  const manifoldInfo = await detectManifoldContract(client, contractAddress);\n  \n  if (manifoldInfo.isManifold && manifoldInfo.extensionAddress) {\n    try {\n      return await getManifoldTokenURI(\n        client,\n        contractAddress,\n        tokenId,\n        manifoldInfo.extensionAddress\n      );\n    } catch (error) {\n      console.warn(\"Failed to get Manifold tokenURI, falling back to standard\", error);\n    }\n  }\n  \n  // Fallback to standard ERC721 tokenURI\n  return await client.readContract({\n    address: getAddress(contractAddress),\n    abi: ERC721_ABI.tokenURI,\n    functionName: \"tokenURI\",\n    args: [BigInt(tokenId)],\n  }) as string;\n}\n\n/**\n * Get Manifold claim information\n */\nexport async function getManifoldClaim(\n  client: PublicClient,\n  contractAddress: Address,\n  instanceId: string,\n  extensionAddress?: Address\n): Promise<ManifoldClaim | null> {\n  try {\n    const extension = extensionAddress || KNOWN_CONTRACTS.manifoldExtension;\n    \n    const claim = await client.readContract({\n      address: getAddress(extension),\n      abi: MANIFOLD_EXTENSION_ABI,\n      functionName: \"getClaim\",\n      args: [getAddress(contractAddress), BigInt(instanceId)],\n    });\n    \n    return claim as unknown as ManifoldClaim;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Get Manifold mint fee\n */\nexport async function getManifoldMintFee(\n  client: PublicClient,\n  extensionAddress?: Address\n): Promise<bigint> {\n  const extension = extensionAddress || KNOWN_CONTRACTS.manifoldExtension;\n  \n  try {\n    return await client.readContract({\n      address: getAddress(extension),\n      abi: MANIFOLD_EXTENSION_ABI,\n      functionName: \"MINT_FEE\",\n    }) as bigint;\n  } catch {\n    // Try MINT_FEE_MERKLE as fallback\n    try {\n      return await client.readContract({\n        address: getAddress(extension),\n        abi: MANIFOLD_EXTENSION_ABI,\n        functionName: \"MINT_FEE_MERKLE\",\n      }) as bigint;\n    } catch {\n      return BigInt(0);\n    }\n  }\n}\n\n/**\n * Check if an address is the zero address\n */\nexport function isZeroAddress(address: string): boolean {\n  return address === \"0x0000000000000000000000000000000000000000\";\n}\n\n/**\n * Format instance ID and token ID for display\n */\nexport function formatManifoldTokenId(instanceId: string, tokenId: string): string {\n  return `${instanceId}-${tokenId}`;\n}",
      "type": "registry:lib",
      "target": ""
    }
  ]
}