{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "session-keys",
  "type": "registry:component",
  "title": "Session Key Button",
  "description": "A comprehensive session key management button that handles creation, validation, and revocation of Abstract Global Wallet session keys",
  "dependencies": [
    "@abstract-foundation/agw-react",
    "@abstract-foundation/agw-client",
    "wagmi",
    "viem",
    "@tanstack/react-query",
    "sonner"
  ],
  "registryDependencies": [
    "button",
    "dropdown-menu"
  ],
  "files": [
    {
      "path": "registry/new-york/blocks/session-keys/session-key-button.tsx",
      "content": "\"use client\";\n\nimport { useAccount } from \"wagmi\";\nimport { Button } from \"@/registry/new-york/ui/button\";\nimport { DropdownMenuItem, DropdownMenuSeparator } from \"@/registry/new-york/ui/dropdown-menu\";\nimport { ConnectWalletButton } from \"@/registry/new-york/blocks/connect-wallet-button/connect-wallet-button\";\nimport { useSessionKey } from \"@/registry/new-york/blocks/session-keys/hooks/use-session-key\";\nimport { useCreateSessionKey } from \"@/registry/new-york/blocks/session-keys/hooks/use-create-session-key\";\nimport { useRevokeSessionKey } from \"@/registry/new-york/blocks/session-keys/hooks/use-revoke-session-key\";\nimport { cn } from \"@/lib/utils\";\nimport { type ClassValue } from \"clsx\";\n\ninterface SessionKeyButtonProps {\n    className?: ClassValue;\n}\n\n/**\n * Session Key Button\n * \n * A comprehensive session key management button that handles:\n * - Wallet connection via ConnectWalletButton integration\n * - Session key creation and validation\n * - Session key revocation with confirmation\n * - Loading states and error handling via toast notifications\n * \n * States:\n * - Not connected: Shows \"Connect Wallet\" button\n * - Connected but no session: Shows \"Create Session Key\" button  \n * - Session exists: Shows \"Session Active\" with dropdown containing revoke option\n */\nexport function SessionKeyButton({ className }: SessionKeyButtonProps) {\n    const { isConnected } = useAccount();\n    const { data: sessionData, isLoading: isSessionLoading } = useSessionKey();\n    const createSessionMutation = useCreateSessionKey();\n    const { revokeSession, isPending: isRevoking } = useRevokeSessionKey();\n\n    // Check if user has an active session\n    const hasActiveSession = !!sessionData;\n\n    // Handle session creation\n    const handleCreateSession = () => {\n        createSessionMutation.mutate();\n    };\n\n    // Handle session revocation\n    const handleRevokeSession = async (e: React.MouseEvent) => {\n        // Prevent dropdown from closing\n        e.preventDefault();\n        e.stopPropagation();\n        \n        if (sessionData?.session) {\n            await revokeSession(sessionData.session);\n        }\n    };\n\n    // Not connected: Use ConnectWalletButton\n    if (!isConnected) {\n        return <ConnectWalletButton className={className} />;\n    }\n\n    // Connected and has active session: Show session status with dropdown\n    if (isConnected && hasActiveSession && !isSessionLoading) {\n        return (\n            <ConnectWalletButton \n                className={className}\n                customDropdownItems={[\n                    <DropdownMenuSeparator key=\"sep\" />,\n                    <DropdownMenuItem \n                        key=\"session-info\" \n                        className=\"focus:bg-transparent cursor-auto\"\n                    >\n                        <div className=\"flex items-center justify-between w-full\">\n                            <span className=\"text-xs text-muted-foreground\">Session:</span>\n                            <div className=\"flex items-center space-x-2\">\n                                <div className=\"h-2 w-2 bg-green-500 rounded-full\" />\n                                <span className=\"text-xs text-green-600 dark:text-green-400\">Active</span>\n                            </div>\n                        </div>\n                    </DropdownMenuItem>,\n                    <DropdownMenuSeparator key=\"sep2\" />,\n                    <DropdownMenuItem \n                        key=\"revoke\" \n                        onClick={handleRevokeSession}\n                        disabled={isRevoking}\n                        className=\"text-destructive\"\n                    >\n                        {isRevoking ? (\n                            <>\n                                <Spinner className=\"mr-2 h-4 w-4 animate-spin\" />\n                                Revoking...\n                            </>\n                        ) : (\n                            <>\n                                <RevokeIcon className=\"mr-2 h-4 w-4\" />\n                                Revoke Session Key\n                            </>\n                        )}\n                    </DropdownMenuItem>\n                ]}\n            />\n        );\n    }\n\n    // Connected but no session OR loading: Show Create Session Key button\n    return (\n        <Button\n            onClick={handleCreateSession}\n            disabled={createSessionMutation.isPending || isSessionLoading}\n            className={cn(\"cursor-pointer group min-w-40\", className)}\n        >\n            {createSessionMutation.isPending ? (\n                <>\n                    <Spinner className=\"mr-2 h-4 w-4 animate-spin\" />\n                    Creating...\n                </>\n            ) : isSessionLoading ? (\n                <>\n                    <Spinner className=\"mr-2 h-4 w-4 animate-spin\" />\n                    Checking...\n                </>\n            ) : (\n                <>\n                    <KeyIcon className=\"mr-2 h-4 w-4\" />\n                    Create Session Key\n                </>\n            )}\n        </Button>\n    );\n}\n\nfunction Spinner({ className }: { className?: ClassValue }) {\n    return (\n        <svg\n            className={cn(\"animate-spin\", className)}\n            xmlns=\"http://www.w3.org/2000/svg\"\n            fill=\"none\"\n            viewBox=\"0 0 24 24\"\n        >\n            <circle\n                className=\"opacity-25\"\n                cx=\"12\"\n                cy=\"12\"\n                r=\"10\"\n                stroke=\"currentColor\"\n                strokeWidth=\"4\"\n            />\n            <path\n                className=\"opacity-75\"\n                fill=\"currentColor\"\n                d=\"m4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"\n            />\n        </svg>\n    );\n}\n\nfunction KeyIcon({ className }: { className?: ClassValue }) {\n    return (\n        <svg\n            className={cn(className)}\n            xmlns=\"http://www.w3.org/2000/svg\"\n            fill=\"none\"\n            viewBox=\"0 0 24 24\"\n            stroke=\"currentColor\"\n            strokeWidth=\"2\"\n        >\n            <path\n                strokeLinecap=\"round\"\n                strokeLinejoin=\"round\"\n                d=\"M15.75 5.25a3 3 0 013 3m3 0a6 6 0 01-7.029 5.912c-.563-.097-1.159.026-1.563.43L10.5 17.25H8.25v2.25H6v2.25H2.25v-2.818c0-.597.237-1.17.659-1.591l6.499-6.499c.404-.404.527-1 .43-1.563A6 6 0 1121.75 8.25z\"\n            />\n        </svg>\n    );\n}\n\nfunction RevokeIcon({ className }: { className?: ClassValue }) {\n    return (\n        <svg\n            className={cn(className)}\n            xmlns=\"http://www.w3.org/2000/svg\"\n            fill=\"none\"\n            viewBox=\"0 0 24 24\"\n            stroke=\"currentColor\"\n            strokeWidth=\"2\"\n        >\n            <path\n                strokeLinecap=\"round\"\n                strokeLinejoin=\"round\"\n                d=\"M6 18L18 6M6 6l12 12\"\n            />\n        </svg>\n    );\n}",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/session-keys/hooks/use-session-key.ts",
      "content": "\"use client\";\n\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useAccount } from \"wagmi\";\nimport { useAbstractClient } from \"@abstract-foundation/agw-react\";\nimport { getStoredSession } from \"../lib/get-stored-session-key\";\n\n/**\n * Hook to retrieve and validate the stored Abstract session\n * @returns The session data with loading and error states\n */\nexport function useSessionKey() {\n    const { address } = useAccount();\n    const { data: abstractClient } = useAbstractClient();\n\n    return useQuery({\n        queryKey: [\"session-key\", address],\n        queryFn: async () => {\n            // These should never happen due to enabled condition, but adding for type safety\n            if (!abstractClient) {\n                throw new Error(\"No Abstract client found\");\n            }\n            if (!address) {\n                throw new Error(\"No wallet address found\");\n            }\n\n            return await getStoredSession(abstractClient, address);\n        },\n        enabled: !!address && !!abstractClient,\n        staleTime: 0, // Always refetch when invalidated\n        retry: (failureCount, error) => {\n            // Don't retry if it's a client/address error (these won't resolve with retry)\n            if (error.message.includes(\"No Abstract client\") || \n                error.message.includes(\"No wallet address\")) {\n                return false;\n            }\n            // Retry network/validation errors up to 2 times\n            return failureCount < 2;\n        },\n        retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000), // Exponential backoff\n    });\n}",
      "type": "registry:hook"
    },
    {
      "path": "registry/new-york/blocks/session-keys/hooks/use-create-session-key.ts",
      "content": "\"use client\";\n\nimport { useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { useAccount } from \"wagmi\";\nimport { useAbstractClient } from \"@abstract-foundation/agw-react\";\nimport { createAndStoreSession } from \"../lib/create-and-store-session-key\";\nimport { toast } from \"sonner\";\n\n/**\n * Hook to create and store Abstract sessions\n * @returns Mutation functions and state for creating sessions\n */\nexport function useCreateSessionKey() {\n    const { data: abstractClient } = useAbstractClient();\n    const { address } = useAccount();\n    const queryClient = useQueryClient();\n\n    const createSessionMutation = useMutation({\n        mutationFn: async () => {\n            if (!address) {\n                throw new Error(\"No wallet address found\");\n            }\n            if (!abstractClient) {\n                throw new Error(\"No Abstract client found\");\n            }\n\n            return createAndStoreSession(abstractClient, address);\n        },\n        onSuccess: async () => {\n            // Invalidate the session query to force a refetch\n            await queryClient.invalidateQueries({\n                queryKey: [\"session-key\", address],\n            });\n            \n            // Also refetch immediately to ensure state updates\n            await queryClient.refetchQueries({\n                queryKey: [\"session-key\", address],\n            });\n            \n            toast.success(\"Session key created successfully\");\n        },\n        onError: (error) => {\n            console.error(\"Failed to create session:\", error);\n            toast.error(\"Failed to create session key\");\n        },\n    });\n\n    return createSessionMutation;\n}",
      "type": "registry:hook"
    },
    {
      "path": "registry/new-york/blocks/session-keys/hooks/use-revoke-session-key.ts",
      "content": "\"use client\";\n\nimport { useRevokeSessions } from \"@abstract-foundation/agw-react\";\nimport { useAccount } from \"wagmi\";\nimport { useQueryClient } from \"@tanstack/react-query\";\nimport { toast } from \"sonner\";\nimport { clearStoredSession } from \"../lib/clear-stored-session-key\";\nimport type { SessionConfig } from \"@abstract-foundation/agw-client/sessions\";\n\n/**\n * Hook to revoke session keys with proper cleanup and error handling\n * @returns Mutation functions and state for revoking sessions\n */\nexport function useRevokeSessionKey() {\n    const { address } = useAccount();\n    const { revokeSessionsAsync, isPending, isError, error } = useRevokeSessions();\n    const queryClient = useQueryClient();\n\n    const revokeSession = async (session: SessionConfig) => {\n        if (!address) {\n            toast.error(\"No wallet address found\");\n            return;\n        }\n\n        try {\n            const result = await revokeSessionsAsync({\n                sessions: session\n            });\n\n            // The result might be undefined or have different structure\n            console.log(\"Revoke result:\", result);\n\n            // Clear local storage after successful revocation\n            clearStoredSession(address);\n            \n            // Invalidate the session query to force a refetch\n            await queryClient.invalidateQueries({\n                queryKey: [\"session-key\", address],\n            });\n            \n            // Also refetch immediately to ensure state updates\n            await queryClient.refetchQueries({\n                queryKey: [\"session-key\", address],\n            });\n\n            toast.success(\"Session key revoked successfully\");\n        } catch (err) {\n            console.error(\"Failed to revoke session:\", err);\n            toast.error(\"Failed to revoke session key\");\n            throw err;\n        }\n    };\n\n    return {\n        revokeSession,\n        isPending,\n        isError,\n        error\n    };\n}",
      "type": "registry:hook"
    },
    {
      "path": "registry/new-york/blocks/session-keys/lib/get-stored-session-key.ts",
      "content": "import type { Address } from \"viem\";\nimport type { AbstractClient } from \"@abstract-foundation/agw-client\";\nimport { getSessionHash, type SessionConfig } from \"@abstract-foundation/agw-client/sessions\";\nimport { LOCAL_STORAGE_KEY_PREFIX, getEncryptionKey, decrypt } from \"./session-encryption-utils\";\nimport { validateSession } from \"./validate-session-key\";\nimport { CALL_POLICIES } from \"@/config/session-key-policies\";\n\nexport interface StoredSessionData {\n    session: SessionConfig;\n    privateKey: Address;\n}\n\n/**\n * @function getStoredSession\n * @description Retrieves, decrypts, and validates a stored session for a wallet address\n * \n * This function performs several steps to securely retrieve and validate a stored session:\n * 1. Checks local storage for encrypted session data under the wallet address key\n * 2. Retrieves the encryption key for the wallet address\n * 3. Decrypts the session data using the encryption key\n * 4. Parses the decrypted data to obtain session information\n * 5. Validates that call policies match current configuration\n * 6. Validates the session by checking its status on-chain\n * \n * @param {AbstractClient} abstractClient - The Abstract client instance\n * @param {Address} userAddress - The wallet address to retrieve session for\n * @returns {Promise<StoredSessionData | null>} The session data if valid, null otherwise\n */\nexport const getStoredSession = async (\n    abstractClient: AbstractClient,\n    userAddress: Address\n): Promise<StoredSessionData | null> => {\n    if (!userAddress) return null;\n\n    const encryptedData = localStorage.getItem(\n        `${LOCAL_STORAGE_KEY_PREFIX}${userAddress}`\n    );\n\n    if (!encryptedData) return null;\n\n    try {\n        const key = await getEncryptionKey(userAddress);\n        const decryptedData = await decrypt(encryptedData, key);\n\n        const sessionData: StoredSessionData = JSON.parse(decryptedData, (_, value) => {\n            // Handle bigint deserialization\n            if (typeof value === \"string\" && /^\\d+$/.test(value)) {\n                try {\n                    return BigInt(value);\n                } catch {\n                    return value;\n                }\n            }\n            return value;\n        });\n\n        // Check if stored call policies match current configuration\n        const storedPoliciesJson = JSON.stringify(\n            sessionData.session.callPolicies,\n            (_, value) => typeof value === \"bigint\" ? value.toString() : value\n        );\n        const currentPoliciesJson = JSON.stringify(\n            CALL_POLICIES,\n            (_, value) => typeof value === \"bigint\" ? value.toString() : value\n        );\n\n        if (storedPoliciesJson !== currentPoliciesJson) {\n            console.log(\"Call policies have changed, session needs refresh\");\n            return null;\n        }\n\n        // Validate the session is still active on-chain\n        const sessionHash = getSessionHash(sessionData.session);\n        const isValid = await validateSession(\n            abstractClient,\n            userAddress,\n            sessionHash\n        );\n\n        return isValid ? sessionData : null;\n    } catch (error) {\n        console.error(\"Failed to retrieve stored session:\", error);\n        return null;\n    }\n};",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/session-keys/lib/create-and-store-session-key.ts",
      "content": "import { generatePrivateKey, privateKeyToAccount } from \"viem/accounts\";\nimport { Address } from \"viem\";\nimport { SessionConfig } from \"@abstract-foundation/agw-client/sessions\";\nimport { LOCAL_STORAGE_KEY_PREFIX, getEncryptionKey, encrypt } from \"./session-encryption-utils\";\nimport { AbstractClient } from \"@abstract-foundation/agw-client\";\nimport { publicClient } from \"@/config/viem-clients\";\nimport { SESSION_KEY_CONFIG } from \"@/config/session-key-policies\";\n\n/**\n * @function createAndStoreSession\n * @description Creates a new Abstract Global Wallet session and stores it securely in local storage\n *\n * @param {Address} userAddress - The wallet address that will own the session\n *\n * @returns {Promise<Object|null>} A promise that resolves to:\n *   - The created session data object (containing `session` and `privateKey`) if successful\n *   - null if the userAddress is empty or invalid\n *\n * @throws {Error} Throws \"Session creation failed\" if there's an error during session creation\n */\nexport const createAndStoreSession = async (\n    abstractClient: AbstractClient,\n    userAddress: Address\n): Promise<{\n    session: SessionConfig;\n    privateKey: Address;\n} | null> => {\n    if (!userAddress) return null;\n\n    try {\n        const sessionPrivateKey = generatePrivateKey();\n        const sessionSigner = privateKeyToAccount(sessionPrivateKey);\n\n        const { session, transactionHash } = await abstractClient.createSession({\n            session: {\n                signer: sessionSigner.address,\n                ...SESSION_KEY_CONFIG,\n            },\n        });\n\n        if (transactionHash) {\n            await publicClient.waitForTransactionReceipt({\n                hash: transactionHash,\n            });\n        } else {\n            throw new Error(\"Transaction hash is null. Session was not created.\");\n        }\n\n        const sessionData = { session, privateKey: sessionPrivateKey };\n        const key = await getEncryptionKey(userAddress);\n        const encryptedData = await encrypt(\n            JSON.stringify(sessionData, (_, value) =>\n                typeof value === \"bigint\" ? value.toString() : value\n            ),\n            key\n        );\n\n        localStorage.setItem(\n            `${LOCAL_STORAGE_KEY_PREFIX}${userAddress}`,\n            encryptedData\n        );\n        return sessionData;\n    } catch (error) {\n        console.error(\"Failed to create session:\", error);\n        throw new Error(`Failed to create session key, ${error}`);\n    }\n};",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/session-keys/lib/clear-stored-session-key.ts",
      "content": "import { LOCAL_STORAGE_KEY_PREFIX, ENCRYPTION_KEY_PREFIX } from \"./session-encryption-utils\";\nimport type { Address } from \"viem\";\n\n/**\n * @function clearStoredSession\n * @description Removes all stored session data for a specific wallet address from local storage\n *\n * This function cleans up both the encrypted session data and the encryption key\n * associated with a wallet address from the browser's local storage. It's typically\n * used when a session has expired, been revoked, or when the user wants to clear\n * their session data for privacy/security reasons.\n *\n * The function removes two items from local storage:\n * 1. The encrypted session data (stored with LOCAL_STORAGE_KEY_PREFIX + address)\n * 2. The encryption key used to encrypt/decrypt the session (stored with ENCRYPTION_KEY_PREFIX + address)\n *\n * @param {Address} userAddress - The wallet address whose session data should be cleared\n */\nexport const clearStoredSession = (userAddress: Address) => {\n    localStorage.removeItem(`${LOCAL_STORAGE_KEY_PREFIX}${userAddress}`);\n    localStorage.removeItem(`${ENCRYPTION_KEY_PREFIX}${userAddress}`);\n};",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/session-keys/lib/session-encryption-utils.ts",
      "content": "import type { Address } from \"viem\";\n\n\n/**\n * @constant {string} LOCAL_STORAGE_KEY_PREFIX\n * @description Prefix used for storing encrypted session data in local storage\n *\n * The actual storage key is created by appending the user's wallet address to this prefix,\n * ensuring each wallet address has its own unique storage key.\n * The prefix includes the current NODE_ENV to separate data between environments.\n */\nexport const LOCAL_STORAGE_KEY_PREFIX = `abstract_session_${process.env.NODE_ENV || \"development\"}_`;\n\n/**\n * @constant {string} ENCRYPTION_KEY_PREFIX\n * @description Prefix used for storing encryption keys in local storage\n *\n * The actual storage key is created by appending the user's wallet address to this prefix,\n * ensuring each wallet address has its own unique encryption key stored separately from the\n * encrypted session data.\n * The prefix includes the current NODE_ENV to separate data between environments.\n */\nexport const ENCRYPTION_KEY_PREFIX = `encryption_key_${process.env.NODE_ENV || \"development\"}_`;\n\n\n/**\n * @function getEncryptionKey\n * @description Retrieves or generates an AES-GCM encryption key for a specific wallet address\n *\n * This function manages encryption keys used to secure session data in local storage.\n * It first checks if an encryption key already exists for the given wallet address.\n * If found, it imports and returns the existing key. Otherwise, it generates a new\n * 256-bit AES-GCM key, stores it in local storage, and returns it.\n *\n * The encryption keys are stored in local storage with a prefix (defined in constants.ts)\n * followed by the wallet address to ensure each wallet has its own unique encryption key.\n *\n * @param {Address} userAddress - The wallet address to get or generate an encryption key for\n *\n * @returns {Promise<CryptoKey>} A promise that resolves to a CryptoKey object that can be\n *                              used with the Web Crypto API for encryption and decryption\n */\nexport const getEncryptionKey = async (\n    userAddress: Address\n): Promise<CryptoKey> => {\n    const storedKey = localStorage.getItem(\n        `${ENCRYPTION_KEY_PREFIX}${userAddress}`\n    );\n\n    if (storedKey) {\n        return crypto.subtle.importKey(\n            \"raw\",\n            Buffer.from(storedKey, \"hex\"),\n            { name: \"AES-GCM\" },\n            false,\n            [\"encrypt\", \"decrypt\"]\n        );\n    }\n\n    const key = await crypto.subtle.generateKey(\n        { name: \"AES-GCM\", length: 256 },\n        true,\n        [\"encrypt\", \"decrypt\"]\n    );\n\n    const exportedKey = await crypto.subtle.exportKey(\"raw\", key);\n    localStorage.setItem(\n        `${ENCRYPTION_KEY_PREFIX}${userAddress}`,\n        Buffer.from(exportedKey).toString(\"hex\")\n    );\n\n    return key;\n};\n\n/**\n * @function encrypt\n * @description Encrypts data using AES-GCM encryption with a provided CryptoKey\n *\n * This function uses the Web Crypto API to encrypt session data for secure storage\n * in the browser's local storage. It generates a random initialization vector (IV)\n * for each encryption operation to ensure security. The encrypted data and IV are\n * both stored in the returned JSON string.\n *\n * @param {string} data - The data to encrypt, typically a stringified JSON object\n *                        containing session information and private keys\n * @param {CryptoKey} key - The AES-GCM encryption key to use\n *\n * @returns {Promise<string>} A promise that resolves to a JSON string containing\n *                           the encrypted data and the initialization vector (IV)\n *                           both encoded as hex strings\n */\nexport const encrypt = async (\n    data: string,\n    key: CryptoKey\n): Promise<string> => {\n    const iv = crypto.getRandomValues(new Uint8Array(12));\n    const encrypted = await crypto.subtle.encrypt(\n        { name: \"AES-GCM\", iv },\n        key,\n        new TextEncoder().encode(data)\n    );\n\n    return JSON.stringify({\n        iv: Buffer.from(iv).toString(\"hex\"),\n        data: Buffer.from(encrypted).toString(\"hex\"),\n    });\n};\n\n/**\n * @function decrypt\n * @description Decrypts data that was encrypted using the encrypt function\n *\n * This function uses the Web Crypto API to decrypt session data that was previously\n * encrypted with the corresponding encrypt function. It expects the input to be a\n * JSON string containing both the encrypted data and the initialization vector (IV)\n * that was used for encryption.\n *\n * @param {string} encryptedData - The encrypted data JSON string containing both the\n *                                encrypted data and the initialization vector (IV)\n *                                as hex strings\n * @param {CryptoKey} key - The AES-GCM decryption key to use (same key used for encryption)\n *\n * @returns {Promise<string>} A promise that resolves to the decrypted data as a string\n *\n * @throws Will throw an error if decryption fails, which may happen if the encryption\n *        key is incorrect or the data has been tampered with\n */\nexport const decrypt = async (\n    encryptedData: string,\n    key: CryptoKey\n): Promise<string> => {\n    const { iv, data } = JSON.parse(encryptedData);\n    const decrypted = await crypto.subtle.decrypt(\n        { name: \"AES-GCM\", iv: Buffer.from(iv, \"hex\") },\n        key,\n        Buffer.from(data, \"hex\")\n    );\n\n    return new TextDecoder().decode(decrypted);\n};",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/session-keys/lib/validate-session-key.ts",
      "content": "import { abstractTestnet } from \"viem/chains\";\nimport type { AbstractClient } from \"@abstract-foundation/agw-client\";\nimport type { Address } from \"viem\";\nimport { chain } from \"@/config/chain\";\nimport { clearStoredSession } from \"./clear-stored-session-key\";\n\n/**\n * @function validateSession\n * @description Checks if a session is valid by querying the session validator contract\n\nThis function verifies whether a session is still valid (active) by calling the\nsessionStatus function on the Abstract Global Wallet session validator contract.\nIf the session is found to be invalid (expired, closed, or non-existent), it\nautomatically cleans up the invalid session data.\n\nThe validation is performed on-chain by checking the status of the session hash\nfor the given wallet address. The status is mapped to the SessionStatus enum,\nwhere Active (1) indicates a valid session.\n * @param {Address} address - The wallet address that owns the session\n * @param {string} sessionHash - The hash of the session to validate\n * @returns {Promise<boolean>} A promise that resolves to a boolean indicating whether\nthe session is valid (true) or not (false)\n */\nexport const validateSession = async (\n    abstractClient: AbstractClient,\n    address: Address,\n    sessionHash: `0x${string}`\n): Promise<boolean> => {\n    try {\n        const status = await abstractClient.getSessionStatus(sessionHash);\n\n        // On Abstract testnet, any session is allowed, so we skip the check\n        // However, on mainnet, we need to check if the session is both whitelisted and active.\n        const isValid =\n            status === SessionStatus.Active ||\n            (chain === abstractTestnet && status === SessionStatus.NotInitialized);\n\n        if (!isValid) {\n            clearStoredSession(address);\n        }\n\n        return isValid;\n    } catch (error) {\n        console.error(\"Failed to validate session:\", error);\n        return false;\n    }\n};\n\n/**\n * @enum {number} SessionStatus\n * @description Represents the possible statuses of an Abstract Global Wallet session\n *\n * This enum maps to the SessionKeyPolicyRegistry.Status values.\n * It's used to determine if a session is valid and can be used to submit transactions on behalf of the wallet.\n */\nenum SessionStatus {\n    /**\n     * Session has not been initialized or does not exist\n     */\n    NotInitialized = 0,\n\n    /**\n     * Session is active and can be used to submit transactions\n     */\n    Active = 1,\n\n    /**\n     * Session has been manually closed/revoked by the wallet owner\n     */\n    Closed = 2,\n\n    /**\n     * Session has expired (exceeded its expiresAt timestamp)\n     */\n    Expired = 3,\n}\n\nexport default SessionStatus;",
      "type": "registry:lib"
    },
    {
      "path": "config/session-key-policies.ts",
      "content": "/**\n * IMPORTANT: https://docs.abs.xyz/abstract-global-wallet/session-keys/going-to-production\n * Your session key config requires approval to operate on Abstract mainnet via whitelist.\n */\n\nimport {\n    LimitType,\n    type SessionConfig,\n} from \"@abstract-foundation/agw-client/sessions\";\nimport { parseEther, toFunctionSelector } from \"viem\";\n\n/**\n * What call policies you wish to allow for the session key\n * Learn more: https://docs.abs.xyz/abstract-global-wallet/agw-client/session-keys/createSession#param-call-policies\n */\nexport const CALL_POLICIES = [\n    {\n        target: \"0xC4822AbB9F05646A9Ce44EFa6dDcda0Bf45595AA\" as `0x${string}`, // Contract address\n        selector: toFunctionSelector(\"mint(address,uint256)\"), // Allowed function\n        // Gas parameters\n        valueLimit: {\n            limitType: LimitType.Unlimited,\n            limit: BigInt(0),\n            period: BigInt(0),\n        },\n        maxValuePerUse: BigInt(0),\n        constraints: [],\n    }\n];\n\n/**\n * What transfer policies you wish to allow for the session key\n * Learn more: https://docs.abs.xyz/abstract-global-wallet/agw-client/session-keys/createSession#param-transfer-policies\n */\nexport const TRANSFER_POLICIES = [\n    // ... Your transfer policies here\n]\n\nexport const SESSION_KEY_CONFIG: Omit<SessionConfig, \"signer\"> = {\n    expiresAt: BigInt(Math.floor(Date.now() / 1000) + 60 * 60 * 24 * 30), // 30 days from now\n    feeLimit: {\n        limitType: LimitType.Lifetime,\n        limit: parseEther(\"1\"), // 1 ETH lifetime gas limit\n        period: BigInt(0),\n    },\n    callPolicies: CALL_POLICIES,\n    transferPolicies: [],\n};",
      "type": "registry:lib",
      "target": "config/session-key-policies.ts"
    },
    {
      "path": "config/viem-clients.ts",
      "content": "import { createPublicClient, createWalletClient, http } from \"viem\";\nimport { eip712WalletActions, publicActionsL2 } from \"viem/zksync\";\nimport { chain } from \"./chain\";\n\n// Global Viem public client instance\nexport const publicClient = createPublicClient({\n    chain: chain,\n    transport: http(),\n}).extend(publicActionsL2());\n\n// Global Viem wallet client instance\nexport const walletClient = createWalletClient({\n    chain: chain,\n    transport: http(),\n}).extend(eip712WalletActions());\n",
      "type": "registry:lib",
      "target": "config/viem-clients.ts"
    },
    {
      "path": "registry/new-york/blocks/connect-wallet-button/connect-wallet-button.tsx",
      "content": "\"use client\"\n\nimport { useLoginWithAbstract } from \"@abstract-foundation/agw-react\"\nimport { Button } from \"@/registry/new-york/ui/button\"\nimport { useAccount, useBalance } from \"wagmi\"\nimport { cn } from \"@/lib/utils\"\nimport { type ClassValue } from \"clsx\"\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuSeparator,\n  DropdownMenuTrigger,\n} from \"@/registry/new-york/ui/dropdown-menu\"\nimport { useState } from \"react\"\n\ninterface ConnectWalletButtonProps {\n  className?: ClassValue\n  customDropdownItems?: React.ReactNode[]\n}\n\n/**\n * Connect Wallet Button for Abstract Global Wallet\n * \n * A comprehensive wallet connection component that handles:\n * - Wallet connection/disconnection via Abstract Global Wallet\n * - Loading states during connection\n * - Balance display with wallet and Abstract logos\n * - Dropdown menu with address copy functionality\n */\nexport function ConnectWalletButton({ className, customDropdownItems }: ConnectWalletButtonProps) {\n  // Wagmi hooks for wallet state and balance\n  const { isConnected, status, address } = useAccount()\n  const { data: balance, isLoading: isBalanceLoading } = useBalance({ address })\n\n  // Abstract Global Wallet authentication\n  const { login, logout } = useLoginWithAbstract()\n\n  // Local state for connection status and copy feedback\n  const isConnecting = status === 'connecting' || status === 'reconnecting'\n  const [copied, setCopied] = useState(false)\n\n  /**\n   * Copy wallet address to clipboard with visual feedback\n   */\n  const copyAddress = async () => {\n    if (address) {\n      await navigator.clipboard.writeText(address)\n      setCopied(true)\n      setTimeout(() => setCopied(false), 2000)\n    }\n  }\n\n  // Loading state: Show connecting button with spinning logo\n  if (isConnecting) {\n    return (\n      <Button\n        disabled\n        className={cn(\"cursor-pointer group min-w-40\", className)}\n      >\n        Connecting...\n        <AbstractLogo className=\"ml-2 animate-spin\" />\n      </Button>\n    )\n  }\n\n  // Disconnected state: Show connect button with hover animation\n  if (!isConnected) {\n    return (\n      <Button\n        onClick={login}\n        className={cn(\"cursor-pointer group min-w-40\", className)}\n      >\n        Connect Wallet\n        <AbstractLogo className=\"ml-2 group-hover:animate-spin transition-transform\" />\n      </Button>\n    )\n  }\n\n  // Connected but loading balance: Show loading state\n  if (isConnected && isBalanceLoading) {\n    return (\n      <Button\n        disabled\n        className={cn(\"cursor-pointer group min-w-40 px-3\", className)}\n      >\n        <WalletIcon className=\"mr-1 h-4 w-4\" />\n        Loading...\n        <AbstractLogo className=\"ml-1 h-4 w-4 animate-spin\" />\n      </Button>\n    )\n  }\n\n  // Format the balance for display (4 decimal places)\n  const formattedBalance = balance\n    ? `${parseFloat(balance.formatted).toFixed(4)} ${balance.symbol}`\n    : '0.0000 ETH'\n\n  // Connected state: Show balance with dropdown menu\n  return (\n    <DropdownMenu>\n      <DropdownMenuTrigger asChild>\n        <Button\n          className={cn(\"cursor-pointer group min-w-40 px-3\", className)}\n        >\n          <WalletIcon className=\"mr-1 h-4 w-4\" />\n          {formattedBalance}\n          <AbstractLogo className=\"ml-1 h-4 w-4\" />\n        </Button>\n      </DropdownMenuTrigger>\n      <DropdownMenuContent align=\"center\" side=\"bottom\" className=\"w-56\">\n        {/* Address display with copy functionality */}\n        <DropdownMenuItem className=\"focus:bg-transparent cursor-auto\">\n          <div className=\"flex items-center justify-between w-full\">\n            <span className=\"text-xs text-muted-foreground font-mono\">\n              {address ? `${address.slice(0, 6)}...${address.slice(-4)}` : 'Connected'}\n            </span>\n            {address && (\n              <Button\n                variant=\"ghost\"\n                size=\"sm\"\n                className=\"h-6 w-6 p-0 hover:bg-accent\"\n                onClick={(e) => {\n                  // Prevent dropdown from closing when copying\n                  e.preventDefault()\n                  e.stopPropagation()\n                  copyAddress()\n                }}\n              >\n                {copied ? (\n                  <CheckIcon className=\"h-2.5 w-2.5\" />\n                ) : (\n                  <CopyIcon className=\"h-2.5 w-2.5\" />\n                )}\n              </Button>\n            )}\n          </div>\n        </DropdownMenuItem>\n        {/* Custom dropdown items or default disconnect */}\n        {customDropdownItems ? (\n          customDropdownItems\n        ) : (\n          <>\n            <DropdownMenuSeparator />\n            <DropdownMenuItem onClick={logout} className=\"text-destructive\">\n              Disconnect\n            </DropdownMenuItem>\n          </>\n        )}\n      </DropdownMenuContent>\n    </DropdownMenu>\n  )\n}\n\nfunction WalletIcon({ className }: { className?: ClassValue }) {\n  return (\n    <svg\n      width=\"16\"\n      height=\"16\"\n      viewBox=\"0 0 640 640\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n      className={cn(className)}\n    >\n      <path\n        d=\"M128 96C92.7 96 64 124.7 64 160L64 448C64 483.3 92.7 512 128 512L512 512C547.3 512 576 483.3 576 448L576 256C576 220.7 547.3 192 512 192L136 192C122.7 192 112 181.3 112 168C112 154.7 122.7 144 136 144L520 144C533.3 144 544 133.3 544 120C544 106.7 533.3 96 520 96L128 96zM480 320C497.7 320 512 334.3 512 352C512 369.7 497.7 384 480 384C462.3 384 448 369.7 448 352C448 334.3 462.3 320 480 320z\"\n        fill=\"currentColor\"\n      />\n    </svg>\n  )\n}\nfunction CopyIcon({ className }: { className?: ClassValue }) {\n  return (\n    <svg\n      width=\"16\"\n      height=\"16\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      className={cn(className)}\n    >\n      <rect width=\"14\" height=\"14\" x=\"8\" y=\"8\" rx=\"2\" ry=\"2\" />\n      <path d=\"M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2\" />\n    </svg>\n  )\n}\n\nfunction CheckIcon({ className }: { className?: ClassValue }) {\n  return (\n    <svg\n      width=\"16\"\n      height=\"16\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      className={cn(className)}\n    >\n      <path d=\"M20 6L9 17l-5-5\" />\n    </svg>\n  )\n}\n\nfunction AbstractLogo({ className }: { className?: ClassValue }) {\n  return (\n    <svg\n      width=\"20\"\n      height=\"18\"\n      viewBox=\"0 0 52 47\"\n      fill=\"none\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n      className={cn(className)}\n    >\n      <path d=\"M33.7221 31.0658L43.997 41.3463L39.1759 46.17L28.901 35.8895C28.0201 35.0081 26.8589 34.5273 25.6095 34.5273C24.3602 34.5273 23.199 35.0081 22.3181 35.8895L12.0432 46.17L7.22205 41.3463L17.4969 31.0658H33.7141H33.7221Z\" fill=\"currentColor\" />\n      <path d=\"M35.4359 28.101L49.4668 31.8591L51.2287 25.2645L37.1978 21.5065C35.9965 21.186 34.9954 20.4167 34.3708 19.335C33.7461 18.2613 33.586 17.0033 33.9063 15.8013L37.6623 1.76283L31.0713 0L27.3153 14.0385L35.4279 28.093L35.4359 28.101Z\" fill=\"currentColor\" />\n      <path d=\"M15.7912 28.101L1.76028 31.8591L-0.00158691 25.2645L14.0293 21.5065C15.2306 21.186 16.2316 20.4167 16.8563 19.335C17.4809 18.2613 17.6411 17.0033 17.3208 15.8013L13.5648 1.76283L20.1558 0L23.9118 14.0385L15.7992 28.093L15.7912 28.101Z\" fill=\"currentColor\" />\n    </svg>\n  )\n}",
      "type": "registry:component"
    }
  ]
}