{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "siwe-button",
  "type": "registry:component",
  "title": "SIWE Button",
  "description": "A streamlined SIWE authentication button that handles wallet connection, message signing, and authentication state",
  "dependencies": [
    "iron-session",
    "viem",
    "wagmi",
    "@tanstack/react-query",
    "sonner"
  ],
  "registryDependencies": [
    "button",
    "card",
    "sonner",
    "dropdown-menu"
  ],
  "files": [
    {
      "path": "registry/new-york/blocks/siwe-button/siwe-button.tsx",
      "content": "\"use client\";\n\nimport { useAccount } from \"wagmi\";\nimport { Button } from \"@/registry/new-york/ui/button\";\nimport { DropdownMenuItem, DropdownMenuSeparator } from \"@/registry/new-york/ui/dropdown-menu\";\nimport { ConnectWalletButton } from \"@/registry/new-york/blocks/connect-wallet-button/connect-wallet-button\";\nimport { useSiweAuthQuery } from \"@/registry/new-york/blocks/siwe-button/hooks/use-siwe-auth-query\";\nimport { useSiweSignInMutation } from \"@/registry/new-york/blocks/siwe-button/hooks/use-siwe-sign-in-mutation\";\nimport { useSiweLogoutMutation } from \"@/registry/new-york/blocks/siwe-button/hooks/use-siwe-logout-mutation\";\nimport { cn } from \"@/lib/utils\";\nimport { type ClassValue } from \"clsx\";\n\ninterface SiweButtonProps {\n  className?: ClassValue;\n}\n\n/**\n * SIWE Button\n * \n * A streamlined authentication button that handles:\n * - Wallet connection via ConnectWalletButton integration\n * - SIWE message signing and verification\n * - Authentication state management with balance display\n * - Loading states and error handling via toast notifications\n * \n * States:\n * - Not connected: Shows \"Connect Wallet\" button\n * - Connected but not authenticated: Shows \"Sign Message\" button  \n * - Authenticated: Shows balance with dropdown containing \"Sign Out\"\n */\nexport function SiweButton({ className }: SiweButtonProps) {\n  const { isConnected } = useAccount();\n  const { data: authData, isLoading: isAuthLoading } = useSiweAuthQuery();\n  const signInMutation = useSiweSignInMutation();\n  const logoutMutation = useSiweLogoutMutation();\n\n  // Check if user is authenticated\n  const isAuthenticated = authData?.ok && authData?.user?.isAuthenticated;\n\n  // Handle sign-in action\n  const handleSignIn = () => {\n    signInMutation.mutate();\n  };\n\n  // Handle sign-out action (SIWE logout + wallet disconnect)\n  const handleSignOut = () => {\n    logoutMutation.mutate();\n  };\n\n  // Not connected: Use ConnectWalletButton\n  if (!isConnected) {\n    return <ConnectWalletButton className={className} />;\n  }\n\n  // Connected and authenticated: Use ConnectWalletButton with custom dropdown\n  if (isConnected && isAuthenticated) {\n    return (\n      <ConnectWalletButton \n        className={className}\n        customDropdownItems={[\n          <DropdownMenuSeparator key=\"sep\" />,\n          <DropdownMenuItem \n            key=\"signout\" \n            onClick={handleSignOut}\n            disabled={logoutMutation.isPending}\n            className=\"text-destructive\"\n          >\n            {logoutMutation.isPending ? (\n              <>\n                <Spinner className=\"mr-2 h-4 w-4 animate-spin\" />\n                Signing out...\n              </>\n            ) : (\n              \"Sign Out\"\n            )}\n          </DropdownMenuItem>\n        ]}\n      />\n    );\n  }\n\n  // Connected but not authenticated OR loading: Show Sign Message button\n  return (\n    <Button\n      onClick={handleSignIn}\n      disabled={signInMutation.isPending || isAuthLoading}\n      className={cn(\"cursor-pointer group min-w-40\", className)}\n    >\n      {signInMutation.isPending ? (\n        <>\n          <Spinner className=\"mr-2 h-4 w-4 animate-spin\" />\n          Signing in...\n        </>\n      ) : isAuthLoading ? (\n        <>\n          <Spinner className=\"mr-2 h-4 w-4 animate-spin\" />\n          Checking...\n        </>\n      ) : (\n        <>\n          <KeyIcon className=\"mr-2 h-4 w-4\" />\n          Sign Message\n        </>\n      )}\n    </Button>\n  );\n}\n\nfunction Spinner({ className }: { className?: ClassValue }) {\n  return (\n    <svg\n      className={cn(\"animate-spin\", className)}\n      xmlns=\"http://www.w3.org/2000/svg\"\n      fill=\"none\"\n      viewBox=\"0 0 24 24\"\n    >\n      <circle\n        className=\"opacity-25\"\n        cx=\"12\"\n        cy=\"12\"\n        r=\"10\"\n        stroke=\"currentColor\"\n        strokeWidth=\"4\"\n      />\n      <path\n        className=\"opacity-75\"\n        fill=\"currentColor\"\n        d=\"m4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"\n      />\n    </svg>\n  );\n}\n\nfunction KeyIcon({ className }: { className?: ClassValue }) {\n  return (\n    <svg\n      className={cn(className)}\n      xmlns=\"http://www.w3.org/2000/svg\"\n      fill=\"none\"\n      viewBox=\"0 0 24 24\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n    >\n      <path\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n        d=\"M15.75 5.25a3 3 0 013 3m3 0a6 6 0 01-7.029 5.912c-.563-.097-1.159.026-1.563.43L10.5 17.25H8.25v2.25H6v2.25H2.25v-2.818c0-.597.237-1.17.659-1.591l6.499-6.499c.404-.404.527-1 .43-1.563A6 6 0 1121.75 8.25z\"\n      />\n    </svg>\n  );\n}",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/siwe-button/hooks/use-siwe-auth-query.ts",
      "content": "\"use client\";\n\nimport { useQuery } from \"@tanstack/react-query\";\nimport { useAccount } from \"wagmi\";\nimport { AuthResponse, ClientSiweConfigurationError } from \"@/registry/new-york/blocks/siwe-button/lib/types\";\n\nconst QUERY_KEYS = {\n  auth: \"siwe-auth\",\n} as const;\n\nasync function fetchAuthUser(): Promise<AuthResponse> {\n  const response = await fetch(\"/api/auth/user\");\n  const result = await response.json();\n\n  // Check for configuration errors and throw proper error type\n  if (result.isConfigurationError) {\n    throw new ClientSiweConfigurationError(result.message);\n  }\n\n  return result;\n}\n\nexport function useSiweAuthQuery() {\n  const { address, isConnected } = useAccount();\n\n  const query = useQuery({\n    queryKey: [QUERY_KEYS.auth, address],\n    queryFn: fetchAuthUser,\n    // Only run query if wallet is connected\n    enabled: isConnected && !!address,\n    // Consider auth data is fresh for 1 minute\n    staleTime: 1000 * 60 * 1, // 1 minute\n    // Only refetch on window focus if data is stale (not on every tab switch)\n    refetchOnWindowFocus: true,\n    // Always recheck when network reconnects\n    refetchOnReconnect: true,\n    // Background recheck every 5 minutes\n    refetchInterval: 1000 * 60 * 5, // 5 minutes\n    // Keep auth data in cache for 10 minutes after component unmount\n    gcTime: 1000 * 60 * 10, // 10 minutes\n    retry: (failureCount, error: Error & { status?: number }) => {\n      // Don't retry if it's a 401 (not authenticated)\n      if (error?.status === 401) {\n        return false;\n      }\n      // Don't retry configuration errors - let them throw\n      if (error instanceof ClientSiweConfigurationError) {\n        return false;\n      }\n      // Retry up to 2 times for other errors\n      return failureCount < 2;\n    },\n    retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),\n  });\n\n  // If there's a configuration error, throw it during render to show in Next.js overlay\n  if (query.error instanceof ClientSiweConfigurationError) {\n    throw query.error;\n  }\n\n  return query;\n}",
      "type": "registry:hook"
    },
    {
      "path": "registry/new-york/blocks/siwe-button/hooks/use-siwe-sign-in-mutation.ts",
      "content": "\"use client\";\n\nimport { useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { useAccount, useSignMessage } from \"wagmi\";\nimport { createSiweMessage } from \"viem/siwe\";\nimport { toast } from \"sonner\";\nimport { AuthResponse, SignInRequest, ClientSiweConfigurationError } from \"@/registry/new-york/blocks/siwe-button/lib/types\";\n\nasync function fetchNonce(): Promise<string> {\n  const response = await fetch(\"/api/auth/nonce\");\n  \n  // Check if it's a JSON error response (configuration error)\n  const contentType = response.headers.get(\"content-type\");\n  if (contentType?.includes(\"application/json\")) {\n    const errorData = await response.json();\n    if (errorData.isConfigurationError) {\n      // Throw the configuration error to bubble up to Next.js\n      throw new ClientSiweConfigurationError(errorData.message);\n    }\n    throw new Error(errorData.message || \"Failed to fetch nonce\");\n  }\n  \n  return response.text();\n}\n\nasync function verifySignature(data: SignInRequest): Promise<AuthResponse> {\n  const response = await fetch(\"/api/auth/verify\", {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(data),\n  });\n  \n  const result = await response.json();\n  \n  // Check for configuration errors and throw them to bubble up\n  if (result.isConfigurationError) {\n    throw new ClientSiweConfigurationError(result.message);\n  }\n  \n  return result;\n}\n\nexport function useSiweSignInMutation() {\n  const { address, chainId } = useAccount();\n  const { signMessageAsync } = useSignMessage();\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: async () => {\n      if (!address || !chainId) {\n        throw new Error(\"Wallet not connected\");\n      }\n\n      // Step 1: Fetch nonce\n      const nonce = await fetchNonce();\n\n      // Step 2: Create SIWE message\n      const message = createSiweMessage({\n        domain: window.location.host,\n        address,\n        statement: \"Sign in with Ethereum to the app.\",\n        uri: window.location.origin,\n        version: \"1\",\n        chainId,\n        nonce,\n        issuedAt: new Date(),\n        expirationTime: new Date(Date.now() + 1000 * 60 * 60 * 24 * 7), // 1 week\n      });\n\n      // Step 3: Sign the message\n      const signature = await signMessageAsync({\n        message,\n      });\n\n      // Step 4: Verify signature\n      const result = await verifySignature({\n        message,\n        signature: signature as `0x${string}`,\n      });\n\n      if (!result.ok) {\n        throw new Error(result.message || \"Sign-in failed\");\n      }\n\n      return result;\n    },\n    onSuccess: () => {\n      // Invalidate auth query to refresh user state\n      queryClient.invalidateQueries({ queryKey: [\"siwe-auth\"] });\n      toast.success(\"Successfully signed in!\");\n    },\n    onError: (error: Error) => {\n      // If it's a configuration error, throw it to show in Next.js overlay\n      if (error instanceof ClientSiweConfigurationError) {\n        throw error;\n      }\n      // Otherwise handle normally\n      console.error(\"Sign-in error:\", error);\n      toast.error(error.message || \"Failed to sign in\");\n    },\n  });\n}",
      "type": "registry:hook"
    },
    {
      "path": "registry/new-york/blocks/siwe-button/hooks/use-siwe-logout-mutation.ts",
      "content": "\"use client\";\n\nimport { useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { useLoginWithAbstract } from \"@abstract-foundation/agw-react\";\nimport { toast } from \"sonner\";\nimport { ClientSiweConfigurationError } from \"@/registry/new-york/blocks/siwe-button/lib/types\";\n\nconst QUERY_KEYS = {\n  auth: \"siwe-auth\",\n} as const;\n\ninterface LogoutResponse {\n  ok: boolean;\n  message?: string;\n  isConfigurationError?: boolean;\n}\n\nasync function logoutUser(): Promise<LogoutResponse> {\n  const response = await fetch(\"/api/auth/logout\", {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n  });\n  \n  const result = await response.json();\n  \n  // Check for configuration errors and throw proper error type\n  if (result.isConfigurationError) {\n    throw new ClientSiweConfigurationError(result.message);\n  }\n  \n  if (!response.ok) {\n    throw new Error(result.message || \"Logout failed\");\n  }\n  \n  return result;\n}\n\n/**\n * React Query mutation hook for SIWE logout functionality.\n * Handles the logout process and updates auth state.\n * \n * @returns UseMutationResult for logout operation\n * \n * @example\n * ```tsx\n * import { useSiweLogoutMutation } from \"@/registry/new-york/blocks/siwe-button/hooks/use-siwe-logout-mutation\";\n * \n * function LogoutButton() {\n *   const logoutMutation = useSiweLogoutMutation();\n *   \n *   return (\n *     <button \n *       onClick={() => logoutMutation.mutate()}\n *       disabled={logoutMutation.isPending}\n *     >\n *       {logoutMutation.isPending ? \"Signing out...\" : \"Sign Out\"}\n *     </button>\n *   );\n * }\n * ```\n * \n * @example\n * ```tsx\n * // With custom success/error handling\n * function MyComponent() {\n *   const logoutMutation = useSiweLogoutMutation({\n *     onSuccess: () => {\n *       // Custom success handling\n *       router.push(\"/\");\n *     },\n *     onError: (error) => {\n *       // Custom error handling\n *       console.error(\"Logout failed:\", error);\n *     }\n *   });\n * \n *   return (\n *     <button onClick={() => logoutMutation.mutate()}>\n *       Sign Out\n *     </button>\n *   );\n * }\n * ```\n */\nexport function useSiweLogoutMutation(options?: {\n  onSuccess?: () => void;\n  onError?: (error: Error) => void;\n}) {\n  const queryClient = useQueryClient();\n  const { logout: walletLogout } = useLoginWithAbstract();\n\n  const mutation = useMutation({\n    mutationFn: logoutUser,\n    onSuccess: (data) => {\n      // Immediately reset auth query data to logged out state\n      queryClient.setQueryData([QUERY_KEYS.auth], {\n        ok: false,\n        message: \"Logged out\"\n      });\n      \n      // Also invalidate to trigger refetch\n      queryClient.invalidateQueries({ queryKey: [QUERY_KEYS.auth] });\n      \n      // Disconnect wallet for complete logout experience\n      walletLogout();\n      \n      // Show success toast\n      toast.success(\"Successfully signed out\");\n      \n      // Call custom success handler if provided\n      options?.onSuccess?.();\n    },\n    onError: (error: Error) => {\n      // Don't show error toast for configuration errors - they should be thrown\n      if (error instanceof ClientSiweConfigurationError) {\n        throw error;\n      }\n      \n      // Show error toast for other errors\n      toast.error(error.message || \"Sign out failed\");\n      \n      // Call custom error handler if provided\n      options?.onError?.(error);\n    },\n  });\n\n  // If there's a configuration error, throw it during render to show in Next.js overlay\n  if (mutation.error instanceof ClientSiweConfigurationError) {\n    throw mutation.error;\n  }\n\n  return mutation;\n}",
      "type": "registry:hook"
    },
    {
      "path": "registry/new-york/blocks/siwe-button/lib/types.ts",
      "content": "\nexport interface SessionData {\n  nonce?: string;\n  isAuthenticated?: boolean;\n  address?: `0x${string}`;\n  chainId?: number;\n  expirationTime?: string;\n}\n\nexport interface AuthUser {\n  isAuthenticated: boolean;\n  address: `0x${string}`;\n  chainId?: number;\n  expirationTime?: string;\n}\n\nexport interface AuthResponse {\n  ok: boolean;\n  message?: string;\n  user?: AuthUser;\n  isConfigurationError?: boolean;\n}\n\nexport interface ConfigurationErrorResponse {\n  ok: false;\n  isConfigurationError: true;\n  message: string;\n}\n\n/**\n * Client-side configuration error that matches the server-side SiweConfigurationError\n */\nexport class ClientSiweConfigurationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"SiweConfigurationError\";\n  }\n}\n\nexport interface SignInRequest {\n  message: string;\n  signature: `0x${string}`;\n}",
      "type": "registry:lib"
    },
    {
      "path": "config/auth.ts",
      "content": "import { SessionOptions } from \"iron-session\";\nimport { chain } from \"./chain\";\n\n/**\n * Custom error class for SIWE authentication configuration issues.\n * These errors should bubble up to show helpful messages to developers.\n */\nexport class SiweConfigurationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"SiweConfigurationError\";\n  }\n}\n\n/**\n * Validates and returns the Iron Session password from environment variables.\n * Throws a SiweConfigurationError if not properly configured.\n */\nfunction getSessionPassword(): string {\n  const password = process.env.IRON_SESSION_PASSWORD;\n  \n  if (!password) {\n    throw new SiweConfigurationError(\n      \"IRON_SESSION_PASSWORD environment variable is required for SIWE authentication.\\n\\n\" +\n      \"This password is used to encrypt session data and must be cryptographically secure.\\n\\n\" +\n      \"To fix this:\\n\" +\n      \"1. Generate a secure password: openssl rand -base64 32\\n\" +\n      \"2. Add it to your .env.local file:\\n\" +\n      '   IRON_SESSION_PASSWORD=\"your_generated_password_here\"\\n' +\n      \"3. Restart your application\\n\\n\" +\n      \"SECURITY WARNING: Never use a weak or default password in production!\"\n    );\n  }\n  \n  if (password.length < 32) {\n    throw new SiweConfigurationError(\n      \"IRON_SESSION_PASSWORD must be at least 32 characters long for security.\\n\" +\n      \"Generate a new secure password using: openssl rand -base64 32\"\n    );\n  }\n  \n  return password;\n}\n\n/**\n * Gets Iron Session configuration for SIWE authentication.\n * Validates IRON_SESSION_PASSWORD on first call.\n */\nexport function getIronOptions(): SessionOptions {\n  return {\n    password: getSessionPassword(),\n    cookieName: \"siwe-session\",\n    cookieOptions: {\n      secure: process.env.NODE_ENV === \"production\",\n      httpOnly: true,\n      sameSite: \"strict\",\n      maxAge: 60 * 60 * 24 * 7, // 7 days\n    },\n  };\n}\n\n// Re-export chain for authentication context\nexport { chain };",
      "type": "registry:lib",
      "target": "config/auth.ts"
    },
    {
      "path": "config/chain.ts",
      "content": "import { abstract, abstractTestnet } from \"viem/chains\";\n\nexport const chain =\n  process.env.NODE_ENV === \"development\"\n    ? abstractTestnet // Local development: Use Abstract Testnet\n    : abstract; // Production: Use Abstract Mainnet\n",
      "type": "registry:lib",
      "target": "config/chain.ts"
    },
    {
      "path": "registry/new-york/blocks/siwe-button/lib/auth-server.ts",
      "content": "import { getIronSession } from \"iron-session\";\nimport { cookies } from \"next/headers\";\nimport { SessionData } from \"@/app/api/auth/nonce/route\";\nimport { chain, getIronOptions, SiweConfigurationError } from \"@/config/auth\";\nimport { AuthUser } from \"./types\";\n\n/**\n * Server-side authentication utilities for SIWE (Sign-in with Ethereum).\n * These functions provide safe and convenient ways to check authentication state\n * on the server-side in API routes, Server Components, and middleware.\n */\n\nexport interface ServerAuthResult {\n  isAuthenticated: boolean;\n  user?: AuthUser;\n  error?: string;\n}\n\n/**\n * Safely retrieves the current authenticated user from the server-side session.\n * Returns null if not authenticated or if there's an error.\n * \n * @returns Promise<ServerAuthResult> - Authentication result with user data or error\n * \n * @example\n * ```tsx\n * // In a Server Component\n * import { getServerAuthUser } from \"@/registry/new-york/blocks/siwe-auth/lib/auth-server\";\n * \n * export default async function ProtectedPage() {\n *   const auth = await getServerAuthUser();\n *   \n *   if (!auth.isAuthenticated) {\n *     return <div>Please sign in to access this page</div>;\n *   }\n *   \n *   return (\n *     <div>\n *       <h1>Welcome!</h1>\n *       <p>Your address: {auth.user?.address}</p>\n *     </div>\n *   );\n * }\n * ```\n * \n * @example\n * ```tsx\n * // In an API route\n * import { getServerAuthUser } from \"@/registry/new-york/blocks/siwe-auth/lib/auth-server\";\n * \n * export async function GET() {\n *   const auth = await getServerAuthUser();\n *   \n *   if (!auth.isAuthenticated) {\n *     return NextResponse.json({ error: \"Unauthorized\" }, { status: 401 });\n *   }\n *   \n *   // Access protected data\n *   const userData = await getUserData(auth.user!.address);\n *   return NextResponse.json(userData);\n * }\n * ```\n */\nexport async function getServerAuthUser(): Promise<ServerAuthResult> {\n  try {\n    const session = await getIronSession<SessionData>(\n      await cookies(),\n      getIronOptions()\n    );\n\n    // Check if user is authenticated\n    if (!session.isAuthenticated || !session.address) {\n      return {\n        isAuthenticated: false,\n        error: \"No user session found\"\n      };\n    }\n\n    // Check if session is expired\n    if (\n      session.expirationTime &&\n      new Date(session.expirationTime).getTime() < Date.now()\n    ) {\n      return {\n        isAuthenticated: false,\n        error: \"SIWE session expired\"\n      };\n    }\n\n    // Check if chain matches\n    if (session.chainId !== chain.id) {\n      return {\n        isAuthenticated: false,\n        error: \"Invalid chain\"\n      };\n    }\n\n    // Return authenticated user data\n    return {\n      isAuthenticated: true,\n      user: {\n        isAuthenticated: session.isAuthenticated,\n        address: session.address,\n        chainId: session.chainId,\n        expirationTime: session.expirationTime,\n      }\n    };\n  } catch (error) {\n    // Handle configuration errors\n    if (error instanceof SiweConfigurationError) {\n      return {\n        isAuthenticated: false,\n        error: `Configuration error: ${error.message}`\n      };\n    }\n    \n    // Handle unexpected errors\n    return {\n      isAuthenticated: false,\n      error: \"Authentication check failed\"\n    };\n  }\n}\n\n/**\n * Requires authentication and throws an error if not authenticated.\n * Useful for API routes that need to ensure authentication.\n * \n * @returns Promise<AuthUser> - The authenticated user data\n * @throws Error if not authenticated\n * \n * @example\n * ```tsx\n * // In an API route\n * import { requireServerAuth } from \"@/registry/new-york/blocks/siwe-auth/lib/auth-server\";\n * \n * export async function POST(request: Request) {\n *   try {\n *     const user = await requireServerAuth();\n *     \n *     // User is guaranteed to be authenticated here\n *     const result = await performProtectedAction(user.address);\n *     return NextResponse.json(result);\n *     \n *   } catch (error) {\n *     return NextResponse.json(\n *       { error: error.message }, \n *       { status: 401 }\n *     );\n *   }\n * }\n * ```\n */\nexport async function requireServerAuth(): Promise<AuthUser> {\n  const auth = await getServerAuthUser();\n  \n  if (!auth.isAuthenticated || !auth.user) {\n    throw new Error(auth.error || \"Authentication required\");\n  }\n  \n  return auth.user;\n}\n\n/**\n * Checks if a user is authenticated (boolean check only).\n * Useful for conditional rendering or simple auth checks.\n * \n * @returns Promise<boolean> - True if authenticated, false otherwise\n * \n * @example\n * ```tsx\n * // In a Server Component\n * import { isServerAuthenticated } from \"@/registry/new-york/blocks/siwe-auth/lib/auth-server\";\n * \n * export default async function HomePage() {\n *   const isAuthenticated = await isServerAuthenticated();\n *   \n *   return (\n *     <div>\n *       {isAuthenticated ? (\n *         <p>Welcome back!</p>\n *       ) : (\n *         <p>Please sign in</p>\n *       )}\n *     </div>\n *   );\n * }\n * ```\n */\nexport async function isServerAuthenticated(): Promise<boolean> {\n  const auth = await getServerAuthUser();\n  return auth.isAuthenticated;\n}\n\n/**\n * Gets the authenticated user's address safely.\n * Returns null if not authenticated.\n * \n * @returns Promise<string | null> - The user's address or null\n * \n * @example\n * ```tsx\n * // In an API route\n * import { getServerAuthAddress } from \"@/registry/new-york/blocks/siwe-auth/lib/auth-server\";\n * \n * export async function GET() {\n *   const address = await getServerAuthAddress();\n *   \n *   if (!address) {\n *     return NextResponse.json({ error: \"Unauthorized\" }, { status: 401 });\n *   }\n *   \n *   const balance = await getBalance(address);\n *   return NextResponse.json({ address, balance });\n * }\n * ```\n */\nexport async function getServerAuthAddress(): Promise<`0x${string}` | null> {\n  const auth = await getServerAuthUser();\n  return auth.user?.address || null;\n}",
      "type": "registry:lib"
    },
    {
      "path": "app/api/auth/nonce/route.ts",
      "content": "import { cookies } from \"next/headers\";\nimport { NextResponse } from \"next/server\";\nimport { generateSiweNonce } from \"viem/siwe\";\nimport { getIronSession } from \"iron-session\";\nimport { getIronOptions, SiweConfigurationError } from \"@/config/auth\";\n\nexport interface SessionData {\n  nonce?: string;\n  isAuthenticated?: boolean;\n  address?: `0x${string}`;\n  chainId?: number;\n  expirationTime?: string;\n}\n\n/**\n * Sign in with Ethereum - Generate a unique nonce for the SIWE message.\n */\nexport async function GET() {\n  try {\n    // The \"session\" here is not related to our session keys.\n    // This is just related to auth / sign in with Ethereum.\n    const session = await getIronSession<SessionData>(\n      await cookies(),\n      getIronOptions()\n    );\n\n    // Generate and store the nonce\n    const nonce = generateSiweNonce();\n    session.nonce = nonce;\n    await session.save();\n\n    // Return the nonce as plain text with no-cache headers\n    return new NextResponse(nonce, {\n      headers: {\n        \"Cache-Control\": \"no-store, no-cache, must-revalidate, proxy-revalidate\",\n        \"Pragma\": \"no-cache\",\n        \"Expires\": \"0\",\n      },\n    });\n  } catch (error) {\n    // Return configuration errors as special response type\n    if (error instanceof SiweConfigurationError) {\n      return NextResponse.json({ \n        ok: false, \n        isConfigurationError: true,\n        message: error.message \n      }, { status: 500 });\n    }\n    // Catch other unexpected errors\n    return NextResponse.json({ ok: false }, { status: 500 });\n  }\n}",
      "type": "registry:page",
      "target": "app/api/auth/nonce/route.ts"
    },
    {
      "path": "app/api/auth/verify/route.ts",
      "content": "import { NextRequest, NextResponse } from \"next/server\";\nimport { parseSiweMessage } from \"viem/siwe\";\nimport { getIronSession } from \"iron-session\";\nimport { cookies } from \"next/headers\";\nimport { SessionData } from \"../nonce/route\";\nimport { createPublicClient, http } from \"viem\";\nimport { chain, getIronOptions, SiweConfigurationError } from \"@/config/auth\";\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json();\n    const { message, signature } = body;\n\n    // Validate required fields\n    if (!message || !signature) {\n      return NextResponse.json(\n        { ok: false, message: \"Message and signature are required.\" },\n        { status: 400 }\n      );\n    }\n\n    // Validate message is a string\n    if (typeof message !== 'string') {\n      return NextResponse.json(\n        { ok: false, message: \"Message must be a string.\" },\n        { status: 400 }\n      );\n    }\n\n    // Validate signature is a valid hex string (supports both EOA and EIP-1271 signatures)\n    if (typeof signature !== 'string' || !/^0x[a-fA-F0-9]+$/.test(signature) || signature.length < 4) {\n      return NextResponse.json(\n        { ok: false, message: \"Invalid signature format.\" },\n        { status: 400 }\n      );\n    }\n\n    // The \"session\" here is not related to our session keys.\n    // This is just related to auth / sign in with Ethereum.\n    const session = await getIronSession<SessionData>(\n      await cookies(),\n      getIronOptions()\n    );\n\n    const publicClient = createPublicClient({\n      chain,\n      transport: http(),\n    });\n\n    try {\n      // Validate nonce exists\n      if (!session.nonce) {\n        return NextResponse.json(\n          { ok: false, message: \"No nonce found. Please request a new nonce first.\" },\n          { status: 422 }\n        );\n      }\n\n      // Parse and validate SIWE message before signature verification\n      const siweMessage = parseSiweMessage(message);\n\n      // Validate chain ID matches expected chain\n      if (siweMessage.chainId !== chain.id) {\n        return NextResponse.json(\n          { ok: false, message: \"Invalid chain ID.\" },\n          { status: 422 }\n        );\n      }\n\n      // Validate domain matches current host to prevent cross-domain replay attacks\n      const requestHost = request.headers.get(\"host\");\n      if (siweMessage.domain !== requestHost) {\n        return NextResponse.json(\n          { ok: false, message: \"Invalid domain.\" },\n          { status: 422 }\n        );\n      }\n\n      // Validate message expiration time\n      if (siweMessage.expirationTime && siweMessage.expirationTime.getTime() <= Date.now()) {\n        return NextResponse.json(\n          { ok: false, message: \"Message has expired.\" },\n          { status: 422 }\n        );\n      }\n\n      // Create and verify the SIWE message (with EIP-1271 support for smart contract wallets)\n      const valid = await publicClient.verifySiweMessage({\n        message,\n        signature: signature as `0x${string}`,\n        nonce: session.nonce,\n        blockTag: 'latest', // EIP-1271 smart contract wallet support\n      });\n\n      // Clear nonce after any verification attempt to prevent reuse\n      session.nonce = undefined;\n\n      // If verification is successful, update the auth state\n      if (valid) {\n        session.isAuthenticated = true;\n        session.address = siweMessage.address as `0x${string}`;\n        session.chainId = siweMessage.chainId;\n        session.expirationTime = siweMessage.expirationTime?.toISOString();\n        await session.save();\n      } else {\n        // Save session to persist nonce clearing even on failure\n        await session.save();\n      }\n\n      if (!valid) {\n        return NextResponse.json(\n          { ok: false, message: \"Invalid signature.\" },\n          { status: 422 }\n        );\n      }\n    } catch {\n      return NextResponse.json(\n        { ok: false, message: \"Verification failed\" },\n        { status: 500 }\n      );\n    }\n\n    return NextResponse.json({ ok: true });\n  } catch (error) {\n    // Return configuration errors as special response type\n    if (error instanceof SiweConfigurationError) {\n      return NextResponse.json({\n        ok: false,\n        isConfigurationError: true,\n        message: error.message\n      }, { status: 500 });\n    }\n    // Catch other unexpected errors\n    return NextResponse.json({ ok: false }, { status: 500 });\n  }\n}",
      "type": "registry:page",
      "target": "app/api/auth/verify/route.ts"
    },
    {
      "path": "app/api/auth/user/route.ts",
      "content": "import { NextResponse } from \"next/server\";\nimport { getIronSession } from \"iron-session\";\nimport { cookies } from \"next/headers\";\nimport { SessionData } from \"../nonce/route\";\nimport { chain, getIronOptions, SiweConfigurationError } from \"@/config/auth\";\n\n/**\n * Sign in with Ethereum - Get the currently authenticated user information.\n * @returns\n */\nexport async function GET() {\n  try {\n    // The \"session\" here is not related to our session keys.\n    // This is just related to auth / sign in with Ethereum.\n    const session = await getIronSession<SessionData>(\n      await cookies(),\n      getIronOptions()\n    );\n\n    if (!session.isAuthenticated || !session.address) {\n      return NextResponse.json(\n        { ok: false, message: \"No user session found.\" },\n        { status: 401 }\n      );\n    }\n\n    if (\n      session.expirationTime &&\n      new Date(session.expirationTime).getTime() < Date.now()\n    ) {\n      return NextResponse.json(\n        { ok: false, message: \"SIWE session expired.\" },\n        { status: 401 }\n      );\n    }\n\n    if (session.chainId !== chain.id) {\n      return NextResponse.json(\n        { ok: false, message: \"Invalid chain.\" },\n        { status: 401 }\n      );\n    }\n\n    // Return the SIWE session data\n    return NextResponse.json({\n      ok: true,\n      user: {\n        isAuthenticated: session.isAuthenticated,\n        address: session.address,\n        chainId: session.chainId,\n        expirationTime: session.expirationTime,\n      },\n    });\n  } catch (error) {\n    // Return configuration errors as special response type\n    if (error instanceof SiweConfigurationError) {\n      return NextResponse.json({ \n        ok: false, \n        isConfigurationError: true,\n        message: error.message \n      }, { status: 500 });\n    }\n    // Catch other unexpected errors\n    return NextResponse.json({ ok: false }, { status: 500 });\n  }\n}",
      "type": "registry:page",
      "target": "app/api/auth/user/route.ts"
    },
    {
      "path": "app/api/auth/logout/route.ts",
      "content": "import { NextResponse } from \"next/server\";\nimport { getIronSession } from \"iron-session\";\nimport { cookies } from \"next/headers\";\nimport { SessionData } from \"../nonce/route\";\nimport { getIronOptions, SiweConfigurationError } from \"@/config/auth\";\n\n/**\n * Sign in with Ethereum - Logout and destroy the current session.\n */\nexport async function POST() {\n  try {\n    const session = await getIronSession<SessionData>(\n      await cookies(),\n      getIronOptions()\n    );\n\n    // Clear all session data\n    session.isAuthenticated = false;\n    session.address = undefined;\n    session.chainId = undefined;\n    session.expirationTime = undefined;\n    session.nonce = undefined;\n    \n    // Destroy the session\n    session.destroy();\n\n    return NextResponse.json({ ok: true, message: \"Successfully logged out\" });\n  } catch (error) {\n    // Let configuration errors bubble up to show helpful messages\n    if (error instanceof SiweConfigurationError) {\n      throw error;\n    }\n    // Catch other unexpected errors\n    return NextResponse.json({ ok: false }, { status: 500 });\n  }\n}",
      "type": "registry:page",
      "target": "app/api/auth/logout/route.ts"
    },
    {
      "path": "registry/new-york/blocks/connect-wallet-button/connect-wallet-button.tsx",
      "content": "\"use client\"\n\nimport { useLoginWithAbstract } from \"@abstract-foundation/agw-react\"\nimport { Button } from \"@/registry/new-york/ui/button\"\nimport { useAccount, useBalance } from \"wagmi\"\nimport { cn } from \"@/lib/utils\"\nimport { type ClassValue } from \"clsx\"\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuSeparator,\n  DropdownMenuTrigger,\n} from \"@/registry/new-york/ui/dropdown-menu\"\nimport { useState } from \"react\"\n\ninterface ConnectWalletButtonProps {\n  className?: ClassValue\n  customDropdownItems?: React.ReactNode[]\n}\n\n/**\n * Connect Wallet Button for Abstract Global Wallet\n * \n * A comprehensive wallet connection component that handles:\n * - Wallet connection/disconnection via Abstract Global Wallet\n * - Loading states during connection\n * - Balance display with wallet and Abstract logos\n * - Dropdown menu with address copy functionality\n */\nexport function ConnectWalletButton({ className, customDropdownItems }: ConnectWalletButtonProps) {\n  // Wagmi hooks for wallet state and balance\n  const { isConnected, status, address } = useAccount()\n  const { data: balance, isLoading: isBalanceLoading } = useBalance({ address })\n\n  // Abstract Global Wallet authentication\n  const { login, logout } = useLoginWithAbstract()\n\n  // Local state for connection status and copy feedback\n  const isConnecting = status === 'connecting' || status === 'reconnecting'\n  const [copied, setCopied] = useState(false)\n\n  /**\n   * Copy wallet address to clipboard with visual feedback\n   */\n  const copyAddress = async () => {\n    if (address) {\n      await navigator.clipboard.writeText(address)\n      setCopied(true)\n      setTimeout(() => setCopied(false), 2000)\n    }\n  }\n\n  // Loading state: Show connecting button with spinning logo\n  if (isConnecting) {\n    return (\n      <Button\n        disabled\n        className={cn(\"cursor-pointer group min-w-40\", className)}\n      >\n        Connecting...\n        <AbstractLogo className=\"ml-2 animate-spin\" />\n      </Button>\n    )\n  }\n\n  // Disconnected state: Show connect button with hover animation\n  if (!isConnected) {\n    return (\n      <Button\n        onClick={login}\n        className={cn(\"cursor-pointer group min-w-40\", className)}\n      >\n        Connect Wallet\n        <AbstractLogo className=\"ml-2 group-hover:animate-spin transition-transform\" />\n      </Button>\n    )\n  }\n\n  // Connected but loading balance: Show loading state\n  if (isConnected && isBalanceLoading) {\n    return (\n      <Button\n        disabled\n        className={cn(\"cursor-pointer group min-w-40 px-3\", className)}\n      >\n        <WalletIcon className=\"mr-1 h-4 w-4\" />\n        Loading...\n        <AbstractLogo className=\"ml-1 h-4 w-4 animate-spin\" />\n      </Button>\n    )\n  }\n\n  // Format the balance for display (4 decimal places)\n  const formattedBalance = balance\n    ? `${parseFloat(balance.formatted).toFixed(4)} ${balance.symbol}`\n    : '0.0000 ETH'\n\n  // Connected state: Show balance with dropdown menu\n  return (\n    <DropdownMenu>\n      <DropdownMenuTrigger asChild>\n        <Button\n          className={cn(\"cursor-pointer group min-w-40 px-3\", className)}\n        >\n          <WalletIcon className=\"mr-1 h-4 w-4\" />\n          {formattedBalance}\n          <AbstractLogo className=\"ml-1 h-4 w-4\" />\n        </Button>\n      </DropdownMenuTrigger>\n      <DropdownMenuContent align=\"center\" side=\"bottom\" className=\"w-56\">\n        {/* Address display with copy functionality */}\n        <DropdownMenuItem className=\"focus:bg-transparent cursor-auto\">\n          <div className=\"flex items-center justify-between w-full\">\n            <span className=\"text-xs text-muted-foreground font-mono\">\n              {address ? `${address.slice(0, 6)}...${address.slice(-4)}` : 'Connected'}\n            </span>\n            {address && (\n              <Button\n                variant=\"ghost\"\n                size=\"sm\"\n                className=\"h-6 w-6 p-0 hover:bg-accent\"\n                onClick={(e) => {\n                  // Prevent dropdown from closing when copying\n                  e.preventDefault()\n                  e.stopPropagation()\n                  copyAddress()\n                }}\n              >\n                {copied ? (\n                  <CheckIcon className=\"h-2.5 w-2.5\" />\n                ) : (\n                  <CopyIcon className=\"h-2.5 w-2.5\" />\n                )}\n              </Button>\n            )}\n          </div>\n        </DropdownMenuItem>\n        {/* Custom dropdown items or default disconnect */}\n        {customDropdownItems ? (\n          customDropdownItems\n        ) : (\n          <>\n            <DropdownMenuSeparator />\n            <DropdownMenuItem onClick={logout} className=\"text-destructive\">\n              Disconnect\n            </DropdownMenuItem>\n          </>\n        )}\n      </DropdownMenuContent>\n    </DropdownMenu>\n  )\n}\n\nfunction WalletIcon({ className }: { className?: ClassValue }) {\n  return (\n    <svg\n      width=\"16\"\n      height=\"16\"\n      viewBox=\"0 0 640 640\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n      className={cn(className)}\n    >\n      <path\n        d=\"M128 96C92.7 96 64 124.7 64 160L64 448C64 483.3 92.7 512 128 512L512 512C547.3 512 576 483.3 576 448L576 256C576 220.7 547.3 192 512 192L136 192C122.7 192 112 181.3 112 168C112 154.7 122.7 144 136 144L520 144C533.3 144 544 133.3 544 120C544 106.7 533.3 96 520 96L128 96zM480 320C497.7 320 512 334.3 512 352C512 369.7 497.7 384 480 384C462.3 384 448 369.7 448 352C448 334.3 462.3 320 480 320z\"\n        fill=\"currentColor\"\n      />\n    </svg>\n  )\n}\nfunction CopyIcon({ className }: { className?: ClassValue }) {\n  return (\n    <svg\n      width=\"16\"\n      height=\"16\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      className={cn(className)}\n    >\n      <rect width=\"14\" height=\"14\" x=\"8\" y=\"8\" rx=\"2\" ry=\"2\" />\n      <path d=\"M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2\" />\n    </svg>\n  )\n}\n\nfunction CheckIcon({ className }: { className?: ClassValue }) {\n  return (\n    <svg\n      width=\"16\"\n      height=\"16\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      className={cn(className)}\n    >\n      <path d=\"M20 6L9 17l-5-5\" />\n    </svg>\n  )\n}\n\nfunction AbstractLogo({ className }: { className?: ClassValue }) {\n  return (\n    <svg\n      width=\"20\"\n      height=\"18\"\n      viewBox=\"0 0 52 47\"\n      fill=\"none\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n      className={cn(className)}\n    >\n      <path d=\"M33.7221 31.0658L43.997 41.3463L39.1759 46.17L28.901 35.8895C28.0201 35.0081 26.8589 34.5273 25.6095 34.5273C24.3602 34.5273 23.199 35.0081 22.3181 35.8895L12.0432 46.17L7.22205 41.3463L17.4969 31.0658H33.7141H33.7221Z\" fill=\"currentColor\" />\n      <path d=\"M35.4359 28.101L49.4668 31.8591L51.2287 25.2645L37.1978 21.5065C35.9965 21.186 34.9954 20.4167 34.3708 19.335C33.7461 18.2613 33.586 17.0033 33.9063 15.8013L37.6623 1.76283L31.0713 0L27.3153 14.0385L35.4279 28.093L35.4359 28.101Z\" fill=\"currentColor\" />\n      <path d=\"M15.7912 28.101L1.76028 31.8591L-0.00158691 25.2645L14.0293 21.5065C15.2306 21.186 16.2316 20.4167 16.8563 19.335C17.4809 18.2613 17.6411 17.0033 17.3208 15.8013L13.5648 1.76283L20.1558 0L23.9118 14.0385L15.7992 28.093L15.7912 28.101Z\" fill=\"currentColor\" />\n    </svg>\n  )\n}",
      "type": "registry:component"
    }
  ]
}