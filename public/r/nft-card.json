{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "nft-card",
  "type": "registry:component",
  "title": "NFT Card",
  "description": "A versatile NFT display component that supports multiple blockchains with rich metadata and custom styling options",
  "dependencies": [
    "viem",
    "clsx",
    "tailwind-merge"
  ],
  "registryDependencies": [
    "https://hellno-mini-app-ui.vercel.app/r/utils.json",
    "https://hellno-mini-app-ui.vercel.app/r/chains.json",
    "https://hellno-mini-app-ui.vercel.app/r/nft-standards.json",
    "https://hellno-mini-app-ui.vercel.app/r/manifold-utils.json"
  ],
  "files": [
    {
      "path": "registry/mini-app/blocks/nft-card/nft-card.tsx",
      "content": "\"use client\";\n\nimport { cn } from \"@/registry/mini-app/lib/utils\";\nimport Image from \"next/image\";\nimport { useState, useEffect } from \"react\";\n\ninterface NFTMetadata {\n  name?: string;\n  description?: string;\n  image?: string;\n  image_url?: string;\n  external_url?: string;\n  attributes?: Array<{\n    trait_type: string;\n    value: string | number;\n    display_type?: string;\n  }>;\n  image_details?: {\n    bytes?: number;\n    format?: string;\n    sha256?: string;\n    width?: number;\n    height?: number;\n  };\n  [key: string]: unknown;\n}\nimport { getAddress, type Address } from \"viem\";\nimport { \n  findChainByName, \n  getPublicClient \n} from \"@/registry/mini-app/lib/chains\";\nimport { \n  ERC721_ABI, \n  ipfsToHttp \n} from \"@/registry/mini-app/lib/nft-standards\";\nimport { \n  getTokenURIWithManifoldSupport \n} from \"@/registry/mini-app/lib/manifold-utils\";\n\n// Base64 placeholder image\nconst PLACEHOLDER_IMAGE =\n  \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAwIiBoZWlnaHQ9IjMwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMzAwIiBoZWlnaHQ9IjMwMCIgZmlsbD0iI2YxZjFmMSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwsIHNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMjQiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGRvbWluYW50LWJhc2VsaW5lPSJtaWRkbGUiIGZpbGw9IiM5OTkiPk5GVCBJbWFnZTwvdGV4dD48L3N2Zz4=\";\n\n\ntype NFTCardProps = {\n  contractAddress: string;\n  tokenId: string;\n  network?: string;\n  alt?: string;\n  className?: string;\n  width?: number;\n  height?: number;\n  rounded?: \"none\" | \"sm\" | \"md\" | \"lg\" | \"xl\" | \"full\";\n  shadow?: boolean;\n  objectFit?: \"contain\" | \"cover\" | \"fill\";\n  fallbackImageUrl?: string;\n  showTitle?: boolean;\n  showNetwork?: boolean;\n  titlePosition?: \"top\" | \"bottom\" | \"outside\";\n  networkPosition?:\n    | \"top-left\"\n    | \"top-right\"\n    | \"bottom-left\"\n    | \"bottom-right\"\n    | \"outside\";\n  customTitle?: string;\n  customNetworkName?: string;\n  loadingComponent?: React.ReactNode;\n  errorComponent?: React.ReactNode;\n  imageProps?: React.ComponentProps<typeof Image>;\n  titleClassName?: string;\n  networkClassName?: string;\n  showOwner?: boolean;\n  onLoad?: (metadata: NFTMetadata) => void;\n  onError?: (error: Error) => void;\n  layout?: \"compact\" | \"card\" | \"detailed\";\n  containerClassName?: string;\n};\n\nexport function NFTCard({\n  contractAddress,\n  tokenId,\n  network = \"ethereum\", // Default to Ethereum mainnet\n  alt = \"NFT Image\",\n  className = \"\",\n  width = 300,\n  height = 300,\n  rounded = \"md\",\n  shadow = true,\n  objectFit = \"cover\",\n  fallbackImageUrl = PLACEHOLDER_IMAGE,\n  showTitle = true,\n  showNetwork = true,\n  titlePosition = \"outside\",\n  networkPosition = \"top-right\",\n  customTitle,\n  customNetworkName,\n  loadingComponent,\n  errorComponent,\n  imageProps,\n  titleClassName = \"\",\n  networkClassName = \"\",\n  showOwner = false,\n  onLoad,\n  onError,\n  layout = \"card\",\n  containerClassName = \"\",\n}: NFTCardProps) {\n  const [imageUrl, setImageUrl] = useState<string>(fallbackImageUrl);\n  const [isLoading, setIsLoading] = useState<boolean>(true);\n  const [error, setError] = useState<string | null>(null);\n  const [title, setTitle] = useState<string | null>(customTitle || null);\n  const [networkName, setNetworkName] = useState<string>(\n    customNetworkName || \"\",\n  );\n  const [owner, setOwner] = useState<string | null>(null);\n  const [metadata, setMetadata] = useState<NFTMetadata | null>(null);\n\n  const roundedClasses = {\n    none: \"rounded-none\",\n    sm: \"rounded-sm\",\n    md: \"rounded-md\",\n    lg: \"rounded-lg\",\n    xl: \"rounded-xl\",\n    full: \"rounded-full\",\n  };\n\n  const networkPositionClasses = {\n    \"top-left\": \"top-0 left-0 rounded-br-md\",\n    \"top-right\": \"top-0 right-0 rounded-bl-md\",\n    \"bottom-left\": \"bottom-0 left-0 rounded-tr-md\",\n    \"bottom-right\": \"bottom-0 right-0 rounded-tl-md\",\n    outside: \"\",\n  };\n\n  useEffect(() => {\n    if (customTitle) {\n      setTitle(customTitle);\n    }\n\n    if (customNetworkName) {\n      setNetworkName(customNetworkName);\n    }\n  }, [customTitle, customNetworkName]);\n\n  useEffect(() => {\n    const fetchNFTData = async () => {\n      if (!contractAddress || !tokenId) return;\n\n      setIsLoading(true);\n      setError(null);\n\n      try {\n        // Skip chain setup if we have customNetworkName\n        if (!customNetworkName) {\n          // Find the chain by name using shared utility\n          const selectedChain = findChainByName(network || \"ethereum\");\n          \n          if (!selectedChain) {\n            console.warn(\n              `Chain \"${network}\" not found, defaulting to Ethereum mainnet`,\n            );\n            setNetworkName(\"Ethereum\");\n          } else {\n            setNetworkName(selectedChain.name);\n          }\n\n          // Create public client using shared utility\n          const client = getPublicClient(selectedChain?.id || 1);\n\n          console.log(\n            `Fetching NFT data from ${selectedChain?.name || 'Ethereum'} for contract ${contractAddress} token ${tokenId}`,\n          );\n\n          // Skip title setup if we have customTitle\n          if (!customTitle) {\n            try {\n              // Get contract name\n              const name = (await client.readContract({\n                address: getAddress(contractAddress),\n                abi: ERC721_ABI.name,\n                functionName: \"name\",\n              })) as string;\n\n              // Set title\n              setTitle(`${name} #${tokenId}`);\n            } catch (nameError) {\n              console.warn(\"Could not fetch NFT name:\", nameError);\n              setTitle(`NFT #${tokenId}`);\n            }\n          }\n\n          // Get owner if requested\n          if (showOwner) {\n            try {\n              const ownerAddress = (await client.readContract({\n                address: getAddress(contractAddress),\n                abi: ERC721_ABI.ownerOf,\n                functionName: \"ownerOf\",\n                args: [BigInt(tokenId)],\n              })) as string;\n\n              setOwner(ownerAddress);\n            } catch (ownerError) {\n              console.warn(\"Could not fetch NFT owner:\", ownerError);\n            }\n          }\n\n          // Get tokenURI with automatic Manifold support\n          let metadataUrl = await getTokenURIWithManifoldSupport(\n            client,\n            getAddress(contractAddress) as Address,\n            tokenId\n          );\n\n          // Handle IPFS URLs using shared utility\n          metadataUrl = ipfsToHttp(metadataUrl);\n\n          // Fetch metadata\n          const fetchedMetadata = await fetch(metadataUrl).then((res) => res.json());\n          console.log(\"NFT metadata:\", fetchedMetadata);\n          \n          // Store metadata in state\n          setMetadata(fetchedMetadata);\n\n          // Call onLoad callback if provided\n          if (onLoad) {\n            onLoad(fetchedMetadata);\n          }\n\n          // Get image URL from metadata\n          let nftImageUrl = fetchedMetadata.image || fetchedMetadata.image_url;\n\n          // Handle IPFS URLs for image using shared utility\n          if (nftImageUrl) {\n            nftImageUrl = ipfsToHttp(nftImageUrl);\n          }\n\n          if (nftImageUrl) {\n            setImageUrl(nftImageUrl);\n          } else {\n            // If no image URL found, use placeholder\n            setImageUrl(fallbackImageUrl);\n          }\n        }\n      } catch (err) {\n        console.error(\"Error fetching NFT:\", err);\n        const error = err instanceof Error ? err : new Error(String(err));\n        setError(`Failed to load NFT data: ${error.message}`);\n        setImageUrl(fallbackImageUrl);\n\n        // Call onError callback if provided\n        if (onError) {\n          onError(error);\n        }\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    fetchNFTData();\n  }, [\n    contractAddress,\n    tokenId,\n    network,\n    fallbackImageUrl,\n    customTitle,\n    customNetworkName,\n    showOwner,\n    onLoad,\n    onError,\n  ]);\n\n  const defaultLoadingComponent = (\n    <div className=\"absolute inset-0 flex items-center justify-center bg-gray-300 dark:bg-gray-700\">\n      <div className=\"w-full h-full bg-gray-200 dark:bg-gray-800 animate-pulse\"></div>\n    </div>\n  );\n\n  const defaultErrorComponent = (\n    <div className=\"absolute inset-0 flex items-center justify-center bg-gray-100 dark:bg-gray-800\">\n      <p className=\"text-red-500 text-sm text-center px-2\">{error}</p>\n    </div>\n  );\n\n  // Render network badge inside the image\n  const renderNetworkBadge = () => {\n    if (!showNetwork || !networkName || networkPosition === \"outside\")\n      return null;\n\n    return (\n      <div\n        className={cn(\n          \"absolute bg-black/60 px-2 py-1 text-white text-xs\",\n          networkPositionClasses[networkPosition],\n          networkClassName,\n        )}\n      >\n        {networkName}\n      </div>\n    );\n  };\n\n  // Render title inside the image\n  const renderInnerTitle = () => {\n    if (!showTitle || !title || titlePosition === \"outside\") return null;\n\n    return (\n      <div\n        className={cn(\n          \"absolute left-0 right-0 bg-black/60 p-2 text-white text-sm truncate\",\n          titlePosition === \"top\" ? \"top-0\" : \"bottom-0\",\n          titleClassName,\n        )}\n      >\n        {title}\n        {showOwner && owner && (\n          <div className=\"text-xs opacity-70 truncate\">\n            Owner: {owner.substring(0, 6)}...{owner.substring(owner.length - 4)}\n          </div>\n        )}\n      </div>\n    );\n  };\n\n  // Render outside information (title, network, owner)\n  const renderOutsideInfo = () => {\n    if (\n      (!showTitle || !title) &&\n      (!showNetwork || !networkName || networkPosition !== \"outside\") &&\n      (!showOwner || !owner || titlePosition !== \"outside\")\n    ) {\n      return null;\n    }\n\n    return (\n      <div className=\"mt-2\">\n        {showTitle && title && titlePosition === \"outside\" && (\n          <div className={cn(\"text-sm font-medium truncate\", titleClassName)}>\n            {title}\n          </div>\n        )}\n\n        {showNetwork && networkName && networkPosition === \"outside\" && (\n          <div\n            className={cn(\n              \"text-xs text-gray-500 dark:text-gray-400\",\n              networkClassName,\n            )}\n          >\n            Network: {networkName}\n          </div>\n        )}\n\n        {showOwner && owner && titlePosition === \"outside\" && (\n          <div className=\"text-xs text-gray-500 dark:text-gray-400 truncate\">\n            Owner: {owner.substring(0, 6)}...{owner.substring(owner.length - 4)}\n          </div>\n        )}\n      </div>\n    );\n  };\n\n  // Apply different layouts\n  const getContainerClasses = () => {\n    switch (layout) {\n      case \"compact\":\n        return \"inline-block\";\n      case \"detailed\":\n        return \"flex flex-col overflow-hidden\";\n      case \"card\":\n      default:\n        return \"\";\n    }\n  };\n\n  // Calculate display dimensions that preserve aspect ratio\n  const getDisplayDimensions = () => {\n    const maxWidth = width || 300;\n    const maxHeight = height || 300;\n    \n    // Check if we have image_details with dimensions\n    if (metadata?.image_details?.width && metadata?.image_details?.height) {\n      const originalAspectRatio = metadata.image_details.width / metadata.image_details.height;\n      \n      // Scale to fit within bounds while preserving aspect ratio\n      const widthBasedHeight = maxWidth / originalAspectRatio;\n      const heightBasedWidth = maxHeight * originalAspectRatio;\n      \n      if (widthBasedHeight <= maxHeight) {\n        // Width is the limiting factor\n        return { \n          width: maxWidth, \n          height: Math.round(widthBasedHeight),\n          useContain: true // Use contain to show full image\n        };\n      } else {\n        // Height is the limiting factor\n        return { \n          width: Math.round(heightBasedWidth), \n          height: maxHeight,\n          useContain: true\n        };\n      }\n    }\n    \n    // No image_details, use provided dimensions\n    return { width: maxWidth, height: maxHeight, useContain: false };\n  };\n\n  const displayDimensions = getDisplayDimensions();\n\n  return (\n    <div className={cn(getContainerClasses(), containerClassName)}>\n      <div\n        className={cn(\n          \"relative overflow-hidden\",\n          roundedClasses[rounded],\n          shadow && \"shadow-md\",\n          className,\n        )}\n        style={{ \n          width: `${displayDimensions.width}px`, \n          height: `${displayDimensions.height}px` \n        }}\n      >\n        {isLoading && (loadingComponent || defaultLoadingComponent)}\n\n        {error && (errorComponent || defaultErrorComponent)}\n\n        <Image\n          src={imageUrl}\n          alt={alt}\n          fill={true}\n          className={cn(\n            displayDimensions.useContain ? \"object-contain\" : `object-${objectFit}`,\n            isLoading && \"opacity-0\"\n          )}\n          unoptimized={true}\n          onError={() => setImageUrl(PLACEHOLDER_IMAGE)}\n          {...imageProps}\n        />\n\n        {renderInnerTitle()}\n        {renderNetworkBadge()}\n      </div>\n\n      {renderOutsideInfo()}\n    </div>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/mini-app/lib/utils.ts",
      "content": "import { clsx, type ClassValue } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}",
      "type": "registry:lib",
      "target": ""
    },
    {
      "path": "registry/mini-app/lib/chains.ts",
      "content": "import { http, type Chain, type PublicClient, createPublicClient } from \"viem\";\nimport * as chains from \"viem/chains\";\n\n/**\n * Centralized chain configuration with Alchemy RPC support\n * Maps chain IDs to their Alchemy subdomain prefixes\n */\nexport const ALCHEMY_CHAIN_CONFIGS: Record<number, { name: string; url: string | null }> = {\n  1: { name: 'ethereum', url: 'eth-mainnet' },\n  10: { name: 'optimism', url: 'opt-mainnet' },\n  137: { name: 'polygon', url: 'polygon-mainnet' },\n  8453: { name: 'base', url: 'base-mainnet' },\n  42161: { name: 'arbitrum', url: 'arb-mainnet' },\n  7777777: { name: 'zora', url: null }, // No Alchemy support\n} as const;\n\n/**\n * Get viem Chain object by ID\n */\nexport function getChainById(chainId: number): Chain {\n  switch (chainId) {\n    case 1:\n      return chains.mainnet;\n    case 10:\n      return chains.optimism;\n    case 137:\n      return chains.polygon;\n    case 8453:\n      return chains.base;\n    case 42161:\n      return chains.arbitrum;\n    case 7777777:\n      return chains.zora;\n    default:\n      // Try to find in all chains\n      const chain = Object.values(chains).find(\n        (c): c is Chain => typeof c === 'object' && c !== null && 'id' in c && c.id === chainId\n      );\n      return chain || chains.mainnet;\n  }\n}\n\n/**\n * Get HTTP transport with optional Alchemy RPC URL\n * Falls back to public RPC if no Alchemy key is available\n */\nexport function getTransport(chainId: number) {\n  const alchemyKey = process.env.NEXT_PUBLIC_ALCHEMY_KEY;\n  const config = ALCHEMY_CHAIN_CONFIGS[chainId];\n  \n  if (config?.url && alchemyKey) {\n    return http(`https://${config.url}.g.alchemy.com/v2/${alchemyKey}`);\n  }\n  \n  // Fallback to default public RPC\n  return http();\n}\n\n/**\n * Create a public client for a specific chain with optimal transport\n */\nexport function getPublicClient(chainId: number): PublicClient {\n  return createPublicClient({\n    chain: getChainById(chainId),\n    transport: getTransport(chainId),\n  }) as PublicClient;\n}\n\n/**\n * Get all available chains mapped by normalized name\n */\nexport function getAvailableChains(): Record<string, Chain> {\n  const availableChains: Record<string, Chain> = {};\n  \n  Object.entries(chains).forEach(([name, chain]) => {\n    if (typeof chain === \"object\" && chain !== null && \"id\" in chain) {\n      availableChains[name.toLowerCase()] = chain as Chain;\n    }\n  });\n  \n  return availableChains;\n}\n\n/**\n * Find chain by network name (fuzzy match)\n */\nexport function findChainByName(networkName: string): Chain | undefined {\n  const normalizedName = networkName.toLowerCase().replace(/[\\s-]/g, \"\");\n  const availableChains = getAvailableChains();\n  \n  // Try exact match first\n  if (availableChains[normalizedName]) {\n    return availableChains[normalizedName];\n  }\n  \n  // Try partial match\n  const matchingChainName = Object.keys(availableChains).find(\n    (chainName) =>\n      chainName.includes(normalizedName) ||\n      normalizedName.includes(chainName)\n  );\n  \n  return matchingChainName ? availableChains[matchingChainName] : undefined;\n}",
      "type": "registry:lib",
      "target": ""
    },
    {
      "path": "registry/mini-app/lib/nft-standards.ts",
      "content": "import { parseAbi, type Address } from \"viem\";\n\n/**\n * Common NFT contract ABIs and standards\n */\n\n// Standard ERC721 functions\nexport const ERC721_ABI = {\n  full: parseAbi([\n    \"function tokenURI(uint256 tokenId) view returns (string)\",\n    \"function name() view returns (string)\",\n    \"function symbol() view returns (string)\",\n    \"function ownerOf(uint256 tokenId) view returns (address)\",\n    \"function balanceOf(address owner) view returns (uint256)\",\n    \"function totalSupply() view returns (uint256)\",\n  ]),\n  \n  // Individual functions for specific use cases\n  tokenURI: parseAbi([\"function tokenURI(uint256 tokenId) view returns (string)\"]),\n  name: parseAbi([\"function name() view returns (string)\"]),\n  symbol: parseAbi([\"function symbol() view returns (string)\"]),\n  ownerOf: parseAbi([\"function ownerOf(uint256 tokenId) view returns (address)\"]),\n};\n\n// Common price discovery functions across NFT contracts\nexport const PRICE_DISCOVERY_ABI = parseAbi([\n  \"function mintPrice() view returns (uint256)\",\n  \"function price() view returns (uint256)\",\n  \"function MINT_PRICE() view returns (uint256)\",\n  \"function getMintPrice() view returns (uint256)\",\n  \"function publicMintPrice() view returns (uint256)\",\n]);\n\n// Common mint functions\nexport const MINT_ABI = parseAbi([\n  \"function mint(uint256 amount) payable\",\n  \"function mint(address to, uint256 amount) payable\",\n  \"function publicMint(uint256 amount) payable\",\n  \"function mintTo(address to, uint256 amount) payable\",\n]);\n\n// Manifold specific ABIs\nexport const MANIFOLD_ABI = {\n  // Contract detection\n  detection: parseAbi([\n    \"function getExtensions() view returns (address[])\",\n  ]),\n  \n  // Extension functions\n  extension: {\n    tokenURI: parseAbi([\n      \"function tokenURI(address creatorContractAddress, uint256 tokenId) view returns (string uri)\",\n    ]),\n    \n    getClaim: [\n      {\n        inputs: [\n          { name: \"creatorContractAddress\", type: \"address\" },\n          { name: \"instanceId\", type: \"uint256\" }\n        ],\n        name: \"getClaim\",\n        outputs: [\n          {\n            components: [\n              { name: \"total\", type: \"uint32\" },\n              { name: \"totalMax\", type: \"uint32\" },\n              { name: \"walletMax\", type: \"uint32\" },\n              { name: \"startDate\", type: \"uint48\" },\n              { name: \"endDate\", type: \"uint48\" },\n              { name: \"storageProtocol\", type: \"uint8\" },\n              { name: \"merkleRoot\", type: \"bytes32\" },\n              { name: \"location\", type: \"string\" },\n              { name: \"tokenId\", type: \"uint256\" },\n              { name: \"cost\", type: \"uint256\" },\n              { name: \"paymentReceiver\", type: \"address\" },\n              { name: \"erc20\", type: \"address\" },\n              { name: \"signingAddress\", type: \"address\" }\n            ],\n            name: \"claim\",\n            type: \"tuple\"\n          }\n        ],\n        stateMutability: \"view\",\n        type: \"function\"\n      }\n    ] as const,\n    \n    getClaimForToken: [\n      {\n        inputs: [\n          { name: \"creatorContractAddress\", type: \"address\" },\n          { name: \"tokenId\", type: \"uint256\" }\n        ],\n        name: \"getClaimForToken\",\n        outputs: [\n          { name: \"instanceId\", type: \"uint256\" },\n          {\n            components: [\n              { name: \"total\", type: \"uint32\" },\n              { name: \"totalMax\", type: \"uint32\" },\n              { name: \"walletMax\", type: \"uint32\" },\n              { name: \"startDate\", type: \"uint48\" },\n              { name: \"endDate\", type: \"uint48\" },\n              { name: \"storageProtocol\", type: \"uint8\" },\n              { name: \"merkleRoot\", type: \"bytes32\" },\n              { name: \"location\", type: \"string\" },\n              { name: \"tokenId\", type: \"uint256\" },\n              { name: \"cost\", type: \"uint256\" },\n              { name: \"paymentReceiver\", type: \"address\" },\n              { name: \"erc20\", type: \"address\" },\n              { name: \"signingAddress\", type: \"address\" }\n            ],\n            name: \"claim\",\n            type: \"tuple\"\n          }\n        ],\n        stateMutability: \"view\",\n        type: \"function\"\n      }\n    ] as const,\n    \n    mint: parseAbi([\n      \"function mint(address creatorContractAddress, uint256 instanceId, uint32 mintIndex, bytes32[] merkleProof, address mintFor) payable\",\n    ]),\n    \n    fees: parseAbi([\n      \"function MINT_FEE() view returns (uint256)\",\n      \"function MINT_FEE_MERKLE() view returns (uint256)\",\n    ]),\n  },\n};\n\n// ERC165 interface detection\nexport const ERC165_ABI = parseAbi([\n  \"function supportsInterface(bytes4 interfaceId) view returns (bool)\",\n]);\n\n// Known contract addresses\nexport const KNOWN_CONTRACTS = {\n  // Manifold extension contracts\n  manifoldExtension: \"0x26BBEA7803DcAc346D5F5f135b57Cf2c752A02bE\" as Address,\n  \n  // Add other known contracts here as needed\n} as const;\n\n// Interface IDs for contract detection\nexport const INTERFACE_IDS = {\n  ERC165: \"0x01ffc9a7\",\n  ERC721: \"0x80ac58cd\",\n  ERC1155: \"0xd9b67a26\",\n  ERC721Metadata: \"0x5b5e139f\",\n} as const;\n\n// IPFS Gateway configuration\nexport const IPFS_GATEWAYS = {\n  default: \"https://ipfs.io/ipfs/\",\n  cloudflare: \"https://cloudflare-ipfs.com/ipfs/\",\n  pinata: \"https://gateway.pinata.cloud/ipfs/\",\n} as const;\n\n/**\n * Convert IPFS URL to HTTP gateway URL\n */\nexport function ipfsToHttp(url: string, gateway: keyof typeof IPFS_GATEWAYS = 'default'): string {\n  if (!url || !url.startsWith('ipfs://')) {\n    return url;\n  }\n  \n  return url.replace('ipfs://', IPFS_GATEWAYS[gateway]);\n}\n\n/**\n * Check if a contract is likely an NFT contract by checking interface support\n */\nexport async function isNFTContract(\n  client: any,\n  contractAddress: Address\n): Promise<{ isNFT: boolean; type?: 'ERC721' | 'ERC1155' }> {\n  try {\n    // Try ERC165 supportsInterface\n    const [supportsERC721, supportsERC1155] = await Promise.all([\n      client.readContract({\n        address: contractAddress,\n        abi: ERC165_ABI,\n        functionName: 'supportsInterface',\n        args: [INTERFACE_IDS.ERC721],\n      }).catch(() => false),\n      client.readContract({\n        address: contractAddress,\n        abi: ERC165_ABI,\n        functionName: 'supportsInterface',\n        args: [INTERFACE_IDS.ERC1155],\n      }).catch(() => false),\n    ]);\n    \n    if (supportsERC721) return { isNFT: true, type: 'ERC721' };\n    if (supportsERC1155) return { isNFT: true, type: 'ERC1155' };\n    \n    // Fallback: try to call name() function\n    const name = await client.readContract({\n      address: contractAddress,\n      abi: ERC721_ABI.name,\n      functionName: 'name',\n    }).catch(() => null);\n    \n    return { isNFT: !!name };\n  } catch {\n    return { isNFT: false };\n  }\n}",
      "type": "registry:lib",
      "target": ""
    },
    {
      "path": "registry/mini-app/lib/manifold-utils.ts",
      "content": "import { type Address, type PublicClient, getAddress } from \"viem\";\nimport { MANIFOLD_ABI, KNOWN_CONTRACTS, ERC721_ABI } from \"./nft-standards\";\n\n/**\n * Manifold contract utilities\n */\n\nexport interface ManifoldDetectionResult {\n  isManifold: boolean;\n  extensionAddress?: Address;\n  extensions?: Address[];\n}\n\nexport interface ManifoldClaim {\n  total: number;\n  totalMax: number;\n  walletMax: number;\n  startDate: bigint;\n  endDate: bigint;\n  storageProtocol: number;\n  merkleRoot: `0x${string}`;\n  location: string;\n  tokenId: bigint;\n  cost: bigint;\n  paymentReceiver: Address;\n  erc20: Address;\n  signingAddress: Address;\n}\n\n/**\n * Detect if a contract is a Manifold contract with extensions\n */\nexport async function detectManifoldContract(\n  client: PublicClient,\n  contractAddress: Address\n): Promise<ManifoldDetectionResult> {\n  try {\n    const extensions = await client.readContract({\n      address: getAddress(contractAddress),\n      abi: MANIFOLD_ABI.detection,\n      functionName: \"getExtensions\",\n    }) as Address[];\n    \n    if (!extensions || extensions.length === 0) {\n      return { isManifold: false };\n    }\n    \n    // Check if it has the known Manifold extension\n    const knownExtension = extensions.find(\n      ext => ext.toLowerCase() === KNOWN_CONTRACTS.manifoldExtension.toLowerCase()\n    );\n    \n    return {\n      isManifold: true,\n      extensionAddress: knownExtension || extensions[0],\n      extensions,\n    };\n  } catch {\n    return { isManifold: false };\n  }\n}\n\n/**\n * Get token URI for a Manifold NFT\n */\nexport async function getManifoldTokenURI(\n  client: PublicClient,\n  contractAddress: Address,\n  tokenId: string,\n  extensionAddress?: Address\n): Promise<string> {\n  const extension = extensionAddress || KNOWN_CONTRACTS.manifoldExtension;\n  \n  return await client.readContract({\n    address: getAddress(extension),\n    abi: MANIFOLD_ABI.extension.tokenURI,\n    functionName: \"tokenURI\",\n    args: [getAddress(contractAddress), BigInt(tokenId)],\n  }) as string;\n}\n\n/**\n * Get token URI with automatic Manifold detection\n */\nexport async function getTokenURIWithManifoldSupport(\n  client: PublicClient,\n  contractAddress: Address,\n  tokenId: string\n): Promise<string> {\n  // Try Manifold first\n  const manifoldInfo = await detectManifoldContract(client, contractAddress);\n  \n  if (manifoldInfo.isManifold && manifoldInfo.extensionAddress) {\n    try {\n      return await getManifoldTokenURI(\n        client,\n        contractAddress,\n        tokenId,\n        manifoldInfo.extensionAddress\n      );\n    } catch (error) {\n      console.warn(\"Failed to get Manifold tokenURI, falling back to standard\", error);\n    }\n  }\n  \n  // Fallback to standard ERC721 tokenURI\n  return await client.readContract({\n    address: getAddress(contractAddress),\n    abi: ERC721_ABI.tokenURI,\n    functionName: \"tokenURI\",\n    args: [BigInt(tokenId)],\n  }) as string;\n}\n\n/**\n * Get Manifold claim information\n */\nexport async function getManifoldClaim(\n  client: PublicClient,\n  contractAddress: Address,\n  instanceId: string,\n  extensionAddress?: Address\n): Promise<ManifoldClaim | null> {\n  try {\n    const extension = extensionAddress || KNOWN_CONTRACTS.manifoldExtension;\n    \n    const claim = await client.readContract({\n      address: getAddress(extension),\n      abi: MANIFOLD_ABI.extension.getClaim,\n      functionName: \"getClaim\",\n      args: [getAddress(contractAddress), BigInt(instanceId)],\n    });\n    \n    return claim as ManifoldClaim;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Get Manifold mint fee\n */\nexport async function getManifoldMintFee(\n  client: PublicClient,\n  extensionAddress?: Address\n): Promise<bigint> {\n  const extension = extensionAddress || KNOWN_CONTRACTS.manifoldExtension;\n  \n  try {\n    return await client.readContract({\n      address: getAddress(extension),\n      abi: MANIFOLD_ABI.extension.fees,\n      functionName: \"MINT_FEE\",\n    }) as bigint;\n  } catch {\n    // Try MINT_FEE_MERKLE as fallback\n    try {\n      return await client.readContract({\n        address: getAddress(extension),\n        abi: MANIFOLD_ABI.extension.fees,\n        functionName: \"MINT_FEE_MERKLE\",\n      }) as bigint;\n    } catch {\n      return BigInt(0);\n    }\n  }\n}\n\n/**\n * Check if an address is the zero address\n */\nexport function isZeroAddress(address: string): boolean {\n  return address === \"0x0000000000000000000000000000000000000000\";\n}\n\n/**\n * Format instance ID and token ID for display\n */\nexport function formatManifoldTokenId(instanceId: string, tokenId: string): string {\n  return `${instanceId}-${tokenId}`;\n}",
      "type": "registry:lib",
      "target": ""
    }
  ],
  "meta": {
    "use_cases": [
      "NFT Showcase",
      "Digital Collectibles Display"
    ],
    "keywords": [
      "nft",
      "collectible",
      "mint"
    ]
  }
}